[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Mining √úbungsmaterial",
    "section": "",
    "text": "Vorwort\nDieses √úbungsmanuskript erg√§nzt das Vorlesungsskript zur Vorlesung Data Mining von Prof.¬†Dr.¬†Yarema Okhrin an der Universit√§t Augsburg. Da dieses Manuskript noch in Arbeit ist sind √Ñnderungen unter vorbehalt m√∂glich und wahrscheinlich.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#warum-sollte-ich-mir-r-anschauen",
    "href": "index.html#warum-sollte-ich-mir-r-anschauen",
    "title": "Data Mining √úbungsmaterial",
    "section": "Warum sollte ich mir R anschauen?",
    "text": "Warum sollte ich mir R anschauen?\nIn fast allen √úbungen werden wir mit der (statistischen) Programmiersprache R arbeiten. Data Mining lebt von der Arbeit mit Daten - sei es die explorative Datenanalyse (EDA), oder das entwickeln von Statistischen Modellen f√ºr Vorhersagen. R ist besonders f√ºr EDA geeignet, da es sich durch verschiedene Zusatzpakete (Libraries) wie dem Tidyverse und Tidymodels auszeichnet. Zum erfolgreichen abschlie√üen dieses Moduls ist deshalb unerl√§sslich, dass man sich in der Vorlesung sowie der √úbung mit der Programmiersprache R auseinander setzt. Sowohl die Theoretischen Konzepte als auch die Anwendung sollen hierbei durch die verschiedenen √úbungen vertieft werden.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#hilfe-mein-code-macht-nicht-das-was-ich-will",
    "href": "index.html#hilfe-mein-code-macht-nicht-das-was-ich-will",
    "title": "Data Mining √úbungsmaterial",
    "section": "Hilfe, mein Code macht nicht das, was ich will!",
    "text": "Hilfe, mein Code macht nicht das, was ich will!\nDebugging, auch bekannt als die Kunst, herauszufinden, warum sich der Code nicht wie erwartet verh√§lt, spielt beim Programmieren eine wesentliche Rolle. Auch nach jahrelanger √úbung werden (gelegentlich) Fehler beim Programmieren auftreten.\nEs gibt viele mehr oder weniger effektive Ans√§tze zur L√∂sung von progamiertechnischen Problemen im Rahmen dieses Kurses. Die meisten Probleme werden von der Form\n\nIch habe den Code bei mir in ein R Skript kopiert und es funktioniert nicht.\n\nsein.\nDie meisten dieser Fehler bzw. Probleme lassen sich mithilfe der folgenden vier Ans√§tzen l√∂sen. Wichtig an dieser Stelle ist zu erw√§hnen, dass die meisten Foren, Websites und Dokumentation f√ºr R in englischer Sprache verfasst wurden, weshalb es sich lohnt die Fehler in der englischen Form zu untersuchen.\n\nViele der h√§ufig auftretenden Fehlermeldungen wurden wahrscheinlich schon in Foren wie Stack Overflow disskutiert. Alternativ k√∂nnen die Suchergebnisse auch Websites wie DataCamp oder GeeksforGeeks enthalten. Diese Websites bieten f√ºr die meisten Probleme und Fehler eine schnelle L√∂sung welche in der regel einfach exakt wie vorgeschlagen in die eigenen Code Skripte √ºbernommen werden k√∂nnen.\nVerwendung eines gro√üen Sprachmodells wie leChat. Wenn es um Fragen zur Fehlersuche oder zur Programmierung im Allgemeinen geht, sind Sprachmodelle hilfreich. Indem man eine Frage als Prompt eingiebt wird in den meisten F√§llen die Ausgabe der Sprachmodelle bereits eine zufriedenstellende Antwort liefern.\nDie interne ‚ÄûHilfe‚Äú-Funktion mag zwar als altmodisch gelten, ist aber ein √§u√üerst effektiver Ansatz zur Fehlersuche. Sie kann wertvolle Erkenntnisse liefern, wenn sich eine Funktion nicht wie erwartet verh√§lt. Wenn sich eine Funktion nicht wie erwartet verh√§lt, √∂ffnet die Eingabe von ?Funktionsname im Konsolen Panel die entsprechende Hilfeseite. Der Abschnitt arguments auf der Hilfeseite erkl√§rt die verschiedenen Eingabeparameter einer Funktion. Der Abschnitt value beschreibt, was f√ºr einen R√ºckgabewert die Funktion hat. Beispiele f√ºr die Verwendung einer Funktion k√∂nnen im letzten Abshcnitt der Hilfe Funktion gefunden werden.\nWenn jeder der oben genannten Schritte fehlschl√§gt, k√∂nnen nat√ºrlich auch Fragen im entsprechenden Digicampus Kurs gestellt werden.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#aufbau-des-manuskripts",
    "href": "index.html#aufbau-des-manuskripts",
    "title": "Data Mining √úbungsmaterial",
    "section": "Aufbau des Manuskripts",
    "text": "Aufbau des Manuskripts\nJedes Kapitel beginnt, je nach Komplexit√§t des Themas, mit einer mehr oder weniger technischen Zusammenfassung und Motivation. Nach diesen Zusammenfassungen folgen Beispiele, welche die Funktionen und Konzepte erg√§nzen. Die √úbungsaufgaben und L√∂sungen finden sich im Anschluss an diese Beispiele.\n\nIm ersten Kapitel werden wir die wichtigsten R Konzepte wiederholen, welche in der √úbung und Vorlesung regelm√§√üig angewendet werden.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "01_Einfuehrung.html",
    "href": "01_Einfuehrung.html",
    "title": "1¬† (Kurz)Einf√ºhrung in R",
    "section": "",
    "text": "1.1 Installieren von R und RStudio\nIn diesem Abschnitt wiederholen wir kurz die Installation von R und RStudio. Obwohl R (die Programmiersprache) mit einer vorinstallierten grafischen Benutzeroberfl√§che (GUI) installiert werden kann, werden wir stattdessen RStudio. RStudio kommt mit einigen Vorteilen gegen√ºber der internen R Gui, wie zum Beispiel das einsehen von Variablenwerten, Plots und Programmcode gleichzeitig. Es ist allerdings wichtig zu beachten, dass RStudio nur dann funktioniert, wenn R zuvor auch installiert wurde.\nNach der erfolgreichen Installation von R und RStudio sollte sich beim Start von RStudio ein Fenster √∂ffnen, das in etwa so aussieht wie das folgende (vgl. RStudio User Guide).\nDas Source Panel zeigt ein .R File namens ggplot2.R. .R Dateien sind das standard R Format in welchen Code geschrieben und gespeichert wird. Eine √§sthetischere Variante sind sogenannte Quarto Markdown Files (Endung .qmd) welche erlauben Text und Code zu kombinieren. Zum Beispiel wurde dieses Manuskript komplett mit Quarto geschrieben üòÅ .\nNat√ºrlich muss man sich nicht zwingend in Quarto einlesen und kann die folgenden Aufgaben auch in normalen .R Skripten ausf√ºhren.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>(Kurz)Einf√ºhrung in R</span>"
    ]
  },
  {
    "objectID": "01_Einfuehrung.html#installieren-von-r-und-rstudio",
    "href": "01_Einfuehrung.html#installieren-von-r-und-rstudio",
    "title": "1¬† (Kurz)Einf√ºhrung in R",
    "section": "",
    "text": "R (f√ºr Windows) kann hier heruntergeladen werden.\nRStudio kann hier heruntergeladen werden.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKurzeinf√ºhrung Quarto\n\n\n\n\n\nQuarto ist in RStudio bereits vorinstalliert, weshalb das Anlegen von neuen Dokumenten sehr leicht ist.\n\nIn RStudio, clicke auf New File -&gt; Quarto Document... im File File tab \nWenn das New Quarto Document Fenster sich √∂ffnet kann man das Outputformat w√§hlen. Das HTML output ist sehr umg√§nglich und kann mit jedem Browser verwendet werden. Durch das ausw√§hlen des create Knopfes √∂ffnet sich dann ein neues Quarto Dokument. \nIm Source Panel wird nun ein Quarto-Beispieldokument angezeigt, welches bearbeitet werden kann. Eventuell muss noch rmarkdown installiert werden, um eine korrekte Darstellung erzeugen zu k√∂nnen (vgl. Markierung 1). Das Quarto-Dokument kann dann durch Anklicken der entsprechenden Abschnitte ge√§ndert werden. R-Code-Zellen k√∂nnen durch Klicken auf den gr√ºnen Pfeil ausgef√ºhrt werden (vgl. Markierung 2). Um neue R-Code-Zellen zwischen Abs√§tzen einzuf√ºgen, kann √ºber die die Registerkarte Einf√ºgen Ausf√ºhrbare Zelle -&gt; R (vgl. Markierung 3) eine neue Code-Zelle . \n\nF√ºr weitere Informationen siehe z.B. Quarto Guide.\n\n\n\n\n\n1.1.1 Arbeiten mit Arbeitspfaden und R Projekten\nNach dem √ñffnen von RStudio kann durch den Befehl getwd() im Konsolen Panel der Pfad des aktuellen Arbeitsverzeichnis ausgegeben werden. Das Arbeitsverzeichnis ist zum Beispiel dann wichtig, wenn wir neue Datein anlegen, oder Datens√§tze einlesen wollen. Wenn der R√ºckgabewert des Befehls getwd() zum Beispiel \"C:/Users/lachlinu/Documents/Vorlesungen/Data_Mining/\" lautet, kann R auf jede Datei im Verzeichnis Data_Mining zugreifen. Eine M√∂glichkeit, das Arbeitsverzeichnis zu √§ndern, ist die Verwendung des Befehls setwd(). Hierbei ist wichtig, entweder den absoluten neuen Pfad, oder den relativen neuen Pfad anzugeben. Falls das Ziel ist, in das /Documents Verzeichnis zu wechseln, so kann man durch die Angabe des relativen Pfades setwd('../../../') das Verzeichnis /Documents ausw√§hlen, sofern das aktuelle Verzeichnis \"C:/Users/lachlinu/Documents/Vorlesungen/Data_Mining/\" ist. Die ../ Notation wird verwendet um das √ºbergeordnete Verzeichnis auszuw√§hlen. Alternativ kann man auch einfach den absoluten Pfad \"C:/Users/lachlinu/Documents\" in den setwd() Befehl einf√ºgen um das Verzeichnis entsprechend zu wechseln. Das manuelle √Ñndern des Verzeichnisses in jedem .R Skript kann schnell m√ºhsam werden, daher ist die Einrichtung eines Projekts eine praktischere Alternative. RStudio-Projekte erm√∂glichen die Erstellung eines individuellen Arbeitsverzeichnisses f√ºr mehrere Kontexte. Zum Beispiel k√∂nnen wir R nicht nur zum L√∂sen von Aufgaben f√ºr Data Mining verwenden, sondern auch f√ºr Abschlussarbeiten. Wenn man also zwei verschiedene Projekte einrichtet, kann man die Arbeitsverzeichnisse und Arbeitsbereiche f√ºr jedes Projekt individuell organisieren.\nDas folgende Beispiel illustriert wie man ein Projekt einrichtet und verwendet:\n\n√úber den File Tab, w√§hle New Project....\n\n\n\n\n\nDurch das w√§hlen von Existing Directory kann man durch den Explorer ein Verzeichnis w√§hlen welches bereits existiert und dann durch den Create Project button ein neus Projekt in diesem Verzeichnis anlegen.\n\n\n\n\n\nDas neue Projekt kann dann einfach angeklickt werden, wodurch sich ein neues RStudio Fenster √∂ffnen sollte.\n\n\n\n\n\n\nSobald sich √ºber das anklicken des Projekts ein neues RStudio Fenster ge√∂ffnet hat wird durch das Ausf√ºhrens des getwd() Befehls der Arbeitspfad des Projekts ausgegeben. Nun kann auch jede Datei in diesem Verzeichnis direkt verwendet werden.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>(Kurz)Einf√ºhrung in R</span>"
    ]
  },
  {
    "objectID": "01_Einfuehrung.html#einfache-r-befehle-und-funktionen",
    "href": "01_Einfuehrung.html#einfache-r-befehle-und-funktionen",
    "title": "1¬† (Kurz)Einf√ºhrung in R",
    "section": "1.2 Einfache R Befehle und Funktionen",
    "text": "1.2 Einfache R Befehle und Funktionen\nNach der erfolgreichen Installation von R und RStudio widmen wir uns nun ein paar grundlegenden Programmierkonzepten in R.\n\n1.2.1 Vektoren, Datens√§tze und Rechenoperationen\n\n1.2.1.1 Vektoren\nVariablen wie Vektoren, oder Arrays werden in R mit dem &lt;- erstellt. Falls zum Beispiel das Ziel ist, einen Vektor zu erstellen, welcher die Werte \\(1,2,3,4,5\\) enth√§lt, gibt es viele Verschiedene M√∂glichkeiten dies zu erreichen.\n\nx1 &lt;- c(1,2,3,4,5)\nx2 &lt;- 1:5\nx3 &lt;- seq(1,5)\n\nJeder der obigen Vektoren enth√§lt die Zahlen 1-5. x1 wurde durch die c() Funktion erstellt, welche einen Vektor entsprechend der √ºbergebenen Argumente erzeugt. x2 wurde mithilfe des : Operators erstellt, welcher einer ganzzahlige Sequenz der Zahlen beginnend mit der Zahl links des Operators bis zur Zahl rechts des Operators erzeugt. Die Erzeugung des Vektors x3 basiert auf der selben Idee wie die Erstellung des Vektors x2, allerdings wurde hier explizit die Funktion seq (Sequence) verwendet um die Zahlenfolge zu generieren. Die seq Funktion erlaubt im Gegensatz zur Verwendung des : Operators einige weitere Argumente wie zum Beispiel das Argument by, oder length.out.\nDer folgende Befehl erzeugt beispielsweise eine Sequenz von 1 bis 5 mit Schrittgr√∂√üe \\(0.5\\).\n\nseq(from = 1,to = 5,by = 0.5)\n\n[1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0\n\n\nDurch das Spezifizieren von length.out kann man die L√§nge der Sequenz steuern. So wird im folgenden Beispiel eine Sequenz von Zahlen zwischen 1 und 5 erzeugt mit der L√§nge 20.\nDie Zuweisung von Werten in Funktionen erfolgt im obigen Beispiel mit dem Symbol =. Die Zuweisung neuer Variablen au√üerhalb von Funktionen kann auch mit dem = Symbol erfolgen, aber es wird selten verwendet und au√üer in einigen pathologischen F√§llen gibt es keinen Unterschied. Die meisten R-Benutzer bevorzugen jedoch die Zuweisung von Umgebungsvariablen mit &lt;-, was in Funktionsaufrufen nicht funktioniert.\n\nseq(1,5,length.out = 20)\n\n [1] 1.000000 1.210526 1.421053 1.631579 1.842105 2.052632 2.263158 2.473684\n [9] 2.684211 2.894737 3.105263 3.315789 3.526316 3.736842 3.947368 4.157895\n[17] 4.368421 4.578947 4.789474 5.000000\n\n\n\n\n\n\n\n\nTip\n\n\n\nDie Argumente einer Funktion m√ºssen nicht immer √ºbergeben werden. Im obigen Beispiel wurden die Bennenungen \"from=\" und \"to=\" weggelassen. Das weglassen der Argumentnamen beim Aufruf der Funktion ist lediglich der Faulheit der programmierenden Person geschuldet. In den meisten F√§llen lohnt es sich Zwecks Lesbarkeit diese zu benennen.\n\n\nDer Abstand zwischen den einzelnen Folgenglieder der Folge ist hierbei gegeben durch\n\\[\n\\frac{5-1}{20-1} = \\frac{4}{19}.\n\\] Im Z√§hler ist steht die L√§nge des Intervalls welche durch obere Grenze - untere Grenze berechnet wird und im Nenner Anzahl der Folgeglieder - 1.\nDas Zugreifen auf Listenelemente wird durch eckige Klammern erm√∂glicht. M√∂chte man zum Beispiel auf das zweite Element des Vektors x2 zugreifen, so wendet man die folgende Notation an:\n\nx2[2]\n\n[1] 2\n\n\nInnerhalb der eckigen Klammer steht der Index, bzw. die Indizes welche zur√ºckgegeben werden sollen. So kann man auch zum Beispiel die ersten zwei Eintr√§ge des Vektors x2 durch folgende Notation ausw√§hlen:\n\nx2[1:2]\n\n[1] 1 2\n\n\n\n\n1.2.1.2 Erstellen von Datens√§tzen\nObwohl die meisten Datens√§tze, welche wir in der √ºbung verwendet bereits erstellt wurden, ist es sehr sinnvoll sich mit der Erstellung von eigenen Datens√§tzen auseinander zu setzen. Besonders wenn man auf Basis bereits existierender Datens√§tze Teildatens√§tze erstellen will, ist diese Kenntnis hilfreich.\nEin Grundlegender Befehl zum erzeugen von Datens√§tzen ist die data.frame Funktion.\n\ndata&lt;- data.frame(\n  x = seq(1,10,length.out = 18),\n  y = letters[1:18],\n  z = unlist(\n        rep(\n          strsplit(\"The quick brown fox jumps over the lazy dog\",\n                   split = \" \"),\n          2)\n  )\n)\n\nDas Datensatz data enth√§lt drei Spalten: x,y,z welche mit verschiedenen Werten erzeugt wurden. Die Spalte x wurde mithilfe der seq Funktion mit 18 Werten bef√ºllt welche zwischen \\(1\\) und \\(10\\) liegen. Die Spalte y wurde mithilfe des vordefinierten letters Vektor bef√ºllt. Dieser enth√§lt die Buchstaben a-z. Hierbei wurden ebenso die 18 Eintr√§ge verwendet. In der letzten Spalte z wurden mehrere Funktionen verschachtelt auf einmal verwendet. Die innerste Funktion strsplit teilt einen gegebenen String (&lt;chr&gt;) Vektor in einzelne Komponenten auf. Die Teilung des langen Strings folgt durch das Argument split. Hier wurde als Split Argument das Leerzeichen \" \" √ºbergeben. Dadurch wird der Satz \"The quick brown fox jumps over the lazy dog\" an jedem Leerzeichen getrennt und eine Liste der einzelnen W√∂rter zur√ºckgegeben. Die rep (Repeat) Funktion wiederholt das √ºbergebene Argument und wiederholt dieses gem√§√ü der √ºbergebnen Zahl. Da der R√ºckgabewert der rep Funktion in diesem Fall eine verschachtelte Liste ist (eine Liste mit zwei Elementen, wobei jedes dieser beiden Elemente wieder selbst eine Liste ist), wir die Verschachtelung √ºber die unlist funktion aufgehoben.\nDer Datensatz hat somit folgende Struktur:\n\ndata\n\n           x y     z\n1   1.000000 a   The\n2   1.529412 b quick\n3   2.058824 c brown\n4   2.588235 d   fox\n5   3.117647 e jumps\n6   3.647059 f  over\n7   4.176471 g   the\n8   4.705882 h  lazy\n9   5.235294 i   dog\n10  5.764706 j   The\n11  6.294118 k quick\n12  6.823529 l brown\n13  7.352941 m   fox\n14  7.882353 n jumps\n15  8.411765 o  over\n16  8.941176 p   the\n17  9.470588 q  lazy\n18 10.000000 r   dog\n\n\nDie Variablen eines Datensatzes k√∂nne √ºber verschiedene Methoden ausgew√§hlt und bearbeitet werden. Im n√§chsten Abschnitt werden hierf√ºr einige dieser Methoden vorgestellt.\n\n\n1.2.1.3 Rechenoperationen in R\nR wurde urspr√ºnglich als statistische Programmiersprache eingef√ºhrt, weshalb bereits viele Funktionen zum berechnen verschiedener Werte vordefiniert sind.\nArithmetische Rechenoperation funktionieren f√ºr Zahlenwerte, Zahlenvektoren und auch gemischten Vektoren.\n\n5+2\n\n[1] 7\n\nseq(1:5)*2\n\n[1]  2  4  6  8 10\n\nseq(1:5)^2\n\n[1]  1  4  9 16 25\n\ncos(seq(0,pi,length.out=10))\n\n [1]  1.0000000  0.9396926  0.7660444  0.5000000  0.1736482 -0.1736482\n [7] -0.5000000 -0.7660444 -0.9396926 -1.0000000\n\n\nObige Beispiele enthalten nur eine kleine Selektion an Methoden welche verwendet werden k√∂nnen, um verschiedene Rechenoperationen durchzuf√ºhren. R Funktioniert gewisserma√üen teilweise wie ein Taschenrechner, weshalb dieser Abschnitt auch nicht in der Tiefe ausgef√ºhrt werden muss.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>(Kurz)Einf√ºhrung in R</span>"
    ]
  },
  {
    "objectID": "01_Einfuehrung.html#arbeiten-mit-datens√§tzen",
    "href": "01_Einfuehrung.html#arbeiten-mit-datens√§tzen",
    "title": "1¬† (Kurz)Einf√ºhrung in R",
    "section": "1.3 Arbeiten mit Datens√§tzen",
    "text": "1.3 Arbeiten mit Datens√§tzen\nIm Zusammenhang mit Data Mining bilden Daten die Grundlage. Egal ob das Ziel ist das Wetter, k√ºnftige Aktienkurse oder die Grundmiete einer potenziellen Mietwohnung vorherzusagen - ohne hochwertige Daten versagen selbst die fortschrittlichsten Modelle. Die Realit√§t sieht jedoch so aus, dass Daten, die wir aus dem Internet, von Servern oder aus Excel Tabellen beziehen, oft alles andere als makellos sind. So k√∂nnen fehlende Werte beispielsweise als NA (Not Available), NaN (Not a Number), NULL oder einfach als leere Zeichenkette ‚Äû‚Äú kodiert sein. Aus diesem Grund ist es wichtig, dass die grundlegenden Datenmanipulationen in R nochmals diskutier werden.\n\n1.3.1 Daten Importieren\nViele Datens√§tze sind zwar bereits in R integriert, bzw. k√∂nnen √ºber Libraries eingelesen werden, allerdings sind einige der Dates√§tze welche wir in der √úbung verwenden nur durch externe Quellen verf√Øugbar. Die meisten Daten werden im csv oder txt Format zur Verf√ºgung gestellt. Es ist deshalb wichtig zu verstehen wie man diese Datens√§tze einliest bevor man tats√§chlich mit diesen arbeitet.\nF√ºr die folgenden √úbungen werden wir das Ramen Dataset untersuchen, welches entweder von der Data Science Plattform Kaggle oder dem untenstehenden Button heruntergeladen werden kann.\n\nDownload ramen Data\n\nDer Ramen Datensatz enth√§lt Informationen √ºber verschiedene Instant Ramen gerichte, welche besonders beliebt unter Studierenden w√§hrend der Pr√ºfungszeit sind.\nDie Daten k√∂nnen dann zum Beispiel in einem Verzeichnis Daten gespeichert werden, welches im gleichen Verzeichnis liegt wie die Projektdatei. Um die Daten einzulesen verwendet man in diesem Fall die read.csv Funktion verwenden. Im folgenden Code Snippet wird der Ramen Datensatz aus dem Verzeichnis /data eingelesen und unter dem Namen data_ramen gespeichert.\n\ndata_ramen &lt;- read.csv(file = \"data/ramen-ratings.csv\")\n\n\n\n1.3.2 Einfache Datenmanipulation und Visualisierung\nF√ºr die meisten √úbungen werden wir das {tidyverse} verwenden, welches eine Sammlung von Libraries enth√§lt die das Arbeiten mit Daten stark vereinfachen. Um die Sammlung von Libraries zu installieren, kann der install.packages() Befehl verwendet werden:\n\ninstall.packages(\"tidyverse\")\n\nNach der Installation kann die Library dann mit dem library Befehl zur aktuellen R Session hinzugef√ºgt werden.\n\nlibrary(\"tidyverse\")\n\n‚îÄ‚îÄ Attaching core tidyverse packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 2.0.0 ‚îÄ‚îÄ\n‚úî dplyr     1.1.4     ‚úî readr     2.1.5\n‚úî forcats   1.0.0     ‚úî stringr   1.5.1\n‚úî ggplot2   3.5.1     ‚úî tibble    3.2.1\n‚úî lubridate 1.9.3     ‚úî tidyr     1.3.1\n‚úî purrr     1.0.2     \n‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ\n‚úñ dplyr::filter() masks stats::filter()\n‚úñ dplyr::lag()    masks stats::lag()\n‚Ñπ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nDas {tidyverse} enth√§lt eine vielzahl wichtiger Libraries, von welchen wir vor allem die folgenden drei verwenden werden:\n\n{ggplot2} f√ºr das Erstellen von Grafiken,\n{dplyr} f√ºr Datenmanipulation,\n{tibble} f√ºr das effiziente Speichern von Daten.\n\nEine sehr gute Einf√ºhrung in diese Library kann unter folgendem Link eingesehen werden. Der Entwickler hinter der Library hat ebenso ein kostenloses Buch namens R for Data Science geschrieben, welches eine sehr Umfangreiche Einf√ºhrung in die verschiedenen Libraries des {tidyverse} gibt.\nNach dem erfolreichen Installieren und hinzuf√ºgen der Library k√∂nnen wir direkt die erste essentielle Funktion nutzen. Die glimpse() Funktion gibt einen kompakten √ºberblick √ºber den Inhalt und die beinhaltenden Datentypen des unterliegenden Datensatzes.\n\nglimpse(data_ramen)\n\nRows: 2,580\nColumns: 7\n$ Review.. &lt;int&gt; 2580, 2579, 2578, 2577, 2576, 2575, 2574, 2573, 2572, 2571, 2‚Ä¶\n$ Brand    &lt;chr&gt; \"New Touch\", \"Just Way\", \"Nissin\", \"Wei Lih\", \"Ching's Secret‚Ä¶\n$ Variety  &lt;chr&gt; \"T's Restaurant Tantanmen \", \"Noodles Spicy Hot Sesame Spicy ‚Ä¶\n$ Style    &lt;chr&gt; \"Cup\", \"Pack\", \"Cup\", \"Pack\", \"Pack\", \"Pack\", \"Cup\", \"Tray\", ‚Ä¶\n$ Country  &lt;chr&gt; \"Japan\", \"Taiwan\", \"USA\", \"Taiwan\", \"India\", \"South Korea\", \"‚Ä¶\n$ Stars    &lt;chr&gt; \"3.75\", \"1\", \"2.25\", \"2.75\", \"3.75\", \"4.75\", \"4\", \"3.75\", \"0.‚Ä¶\n$ Top.Ten  &lt;chr&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"‚Ä¶\n\n\nRows: 2,580 bedeutet, dass der Datensatz 2.580 Eintr√§ge hat, und Columns: 7 bedeutet, dass der Datensatz jeweils 7 Variablen enth√§lt. Die erste Spalte enth√§lt die Variablennamen, ihre Datentypen und einige Anfangswerte, wodurch der Datensatz eine klare Struktur erh√§lt. Wir k√∂nnen bereits sehen, dass au√üer einer Variablen (Review) jede andere Variable vom Typ chr ist, was f√ºr character oder string steht.\n\n1.3.2.1 Anpassen der Variablen\nBeim Aufrufen der glimpse() Funktion ist direkt aufgefallen, dass die Variablennamen teilweise inkonsistent sind. Die erste Spalte hat zum Beispiel den Namen \"Review..\". Um eine konsistente und einfache Namengebung zu verwenden, k√∂nnen wir die janitor::clean_names Funktion verwenden.\n\n\n\n\n\n\nTip\n\n\n\nDie obige Notation wird verwendet, wenn man zus√§tzlich zum Funktionsname auch noch die Library der Funktion benennen will. Besonders bei der vermeidung von sogenannten ‚Äònamespace conflicts‚Äô, bei welchen zwei Funktionen aus verschiedenen Libraries die gleichen Namen besitzen.\n\n\nAuch hier gilt: Eventuell muss die {janitor} Library zuerst installiert werden, bevor die Funktion verwendet werden kann. Die Installation kann analog wie im Beispiel zur {tidyverse} Library durchgef√ºhrt werden.\nWenn die Library dann erfolgreich installiert wurde, k√∂nnen wir die Daten mit einer angepassten Version √ºberschreiben:\n\ndata_ramen &lt;- janitor::clean_names(dat = data_ramen)\n\nNach dem Ab√§ndern der Daten und einem erneuten Aufrufen der glimpse() Funktion kann die √Ñnderung der Variablennamen eingesehen werden:\n\nglimpse(data_ramen)\n\nRows: 2,580\nColumns: 7\n$ review  &lt;int&gt; 2580, 2579, 2578, 2577, 2576, 2575, 2574, 2573, 2572, 2571, 25‚Ä¶\n$ brand   &lt;chr&gt; \"New Touch\", \"Just Way\", \"Nissin\", \"Wei Lih\", \"Ching's Secret\"‚Ä¶\n$ variety &lt;chr&gt; \"T's Restaurant Tantanmen \", \"Noodles Spicy Hot Sesame Spicy H‚Ä¶\n$ style   &lt;chr&gt; \"Cup\", \"Pack\", \"Cup\", \"Pack\", \"Pack\", \"Pack\", \"Cup\", \"Tray\", \"‚Ä¶\n$ country &lt;chr&gt; \"Japan\", \"Taiwan\", \"USA\", \"Taiwan\", \"India\", \"South Korea\", \"J‚Ä¶\n$ stars   &lt;chr&gt; \"3.75\", \"1\", \"2.25\", \"2.75\", \"3.75\", \"4.75\", \"4\", \"3.75\", \"0.2‚Ä¶\n$ top_ten &lt;chr&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"‚Ä¶\n\n\n\n\n\n1.3.3 Anpassen von Datens√§tzen\n\n1.3.3.1 Die mutateFunktion\nUm Anpassungen an den Daten vorzunehmen, bietet sich die dplyr::mutate Funktion perfekt an.\nDie mutate Funktion kann entweder neue Spalten generieren, oder vorhandene Spalten modifizieren. Im folgenden Beispiel wird die mutate Funktion daf√ºr verwendet die Variable stars vom Datentyp &lt;chr&gt; in &lt;dbl&gt; umzuwandeln und die Variable top_ten zu entfernen.\n\ndata_ramen &lt;- data_ramen %&gt;% \n  mutate(\n    stars = as.double(stars),\n    top_ten = NULL\n         )\n\nWarning: There was 1 warning in `mutate()`.\n‚Ñπ In argument: `stars = as.double(stars)`.\nCaused by warning:\n! NAs durch Umwandlung erzeugt\n\n\n\nIn der ersten Zeile der Codezelle wird angegeben, dass der Datensatz data_ramen durch eine ver√§nderte Version √ºberschrieben werden soll.\nDer urspr√ºngliche Datensatz data_ramen wird in der zweiten Zeile an die mutateFunktion √ºbergeben.\nIn der dritten Zeile wird als erstes Argument die Variable stars durch die Ausgabe der Funktion as.double mit Argument stars √ºberschrieben. Die Funktion as.double ist eine Funktion der {base} library.\nIn der vierten Zeile wird als weiteres Argument (separiert durch ein , aus der vorherigen Zeile) die den Variable top_ten entfertn, indem die Variable mit NULL √ºberschrieben wird.\n\nDas ausf√ºhren der vorherigen Code Zelle wirft folgende Warnung:\n\nWarning message: There was 1 warning in mutate(). ‚Ñπ In argument: stars = as.double(stars). Caused by warning: ! NAs introduced by coercion\n\nDies liegt daran, dass in der Variable stars fehlende Werte vorhanden sind. Durch das Anwenden der as.double Funktion wurden die Fehlenden werte in NA Werte umgewandelt, was aber erstmal kein Problem darstellt.\n\n\n1.3.3.2 Der Pipe Operator %&gt;%\nIn der Code Zelle\n\ndata_ramen &lt;- data_ramen %&gt;% \n  mutate(...)\n\nwurde in der ersten Zeile der sogenannte Pipe Operator %&gt;% verwendet. Der Pipe Operator ist ein m√§chtiges Werkzeug aus der {magittr} Library welche erlaubt Verkettungen von Funktionen durchzuf√ºhren. Die Wortw√∂rtliche √ºbersetzung ‚ÄúRohr‚Äù steht hierbei sinnbildlich f√ºr den Vorgang dass auf der einen Seite (links) z.B. Daten √ºbergeben werden und auf der anderen Seite (rechts) nach den durchgef√ºhrten Transformationen ausgegeben werden. Die St√§rke des Operators liegt hierbei in der M√∂glichkeit viele Operationen sequentiell durchzuf√ºhren und dabei die Lesbarkeit und √úbersichtlichkeit zu bewahren.\nSo kann man zum Beispiel nach der initialen Transformation durch die mutate Funktion die na.omit Funktion auf die resultierenden Daten angewendet werden, um alle NA, bzw. NaN Werte zu entfernen.\n\ndata_ramen &lt;- data_ramen %&gt;% \n  mutate(\n    stars = as.double(stars),\n    top_ten = NULL\n         ) %&gt;%\n  na.omit()\n\nDurch die Anwendung des Pipe Operators muss auch der Datensatz im Obigen Beispiel nicht als Argument der Funktion √ºbergeben werden. Ohne den Pipe Operator k√∂nnte man das obige Beispiel auch wie folgt implementieren:\n\ndata_ramen &lt;- mutate(na.omit(data_ramen),\n                     stars = as.double(stars),\n                     top_ten = NULL)\n\n\n\n1.3.3.3 Filtern, Gruppieren und Zusammenfassen von Datasets\nIm vorherigen Abschnitt haben wir uns mit grundlegenden Funktionen f√ºr das Anpassen der Daten besch√§ftigt. Ein weiterer wichtiger Aspekt beim Umgang mit Daten ist die sogenannte Explorative Datenanalyse (EDA). Hierbei werden die unterliegenden Daten mithilfe von deskriptiven und induktiven Methoden untersucht. Wichtige Funktionen in diesem Kontext sind die filter, group_by und summarise Funktionen aus dem {dplyr} Package.\nAngenommen wir wollen f√ºr das data_ramen Dataset herausfinden, wie viele Marken (brands) mehr als 30 Sorten (varieties) an Instant Ramen Nudeln anbieten. Intuitiv macht es Sinn die Eintr√§ge des Datensatzes zu Gruppieren, wobei jede Marke einer Gruppe entspricht. Nach der Bildung von Gruppen erzeugt durch die Marken, kann dann f√ºr jede Gruppe die Anzahl der Eintr√§ge innerhalb der Gruppen berechnet werden. Abschlie√üend filtert man die resultierenden Ergebnisse nach dem Kriterium, dass mindestens 30 Eintr√§ge in einer Gruppe enthalten sein m√ºssen. Diese beschriebene Heuristik l√§sst sich mithilfe des folgenden Skripts umsetzen:\n\ndata_ramen %&gt;%\n  group_by(brand) %&gt;%\n  summarise(num_var = n()) %&gt;%\n  filter(num_var &gt; 30)\n\n# A tibble: 12 √ó 2\n   brand         num_var\n   &lt;chr&gt;           &lt;int&gt;\n 1 Indomie            53\n 2 Lucky Me!          34\n 3 Mama               71\n 4 Maruchan           76\n 5 Myojo              63\n 6 Nissin            381\n 7 Nongshim           98\n 8 Ottogi             45\n 9 Paldo              66\n10 Samyang Foods      51\n11 Vifon              33\n12 Vina Acecook       34\n\n\nFassen wir die Schritte im obigen Skript nochmal zusammen:\n\nIn der ersten Zeile wird der Datensatz data_ramen durch den Pipe Operator in die folgenden Funktionen √ºbergeben.\nIn der zweiten Zeile wird der group_by Befehl verwendet um die Eintr√§ge des Datensatzes nach der Variable brand zu Gruppieren.\n\n\n\n\n\n\nTip\n\n\n\nDurch das alleinige Aufrufen der group_by Funktion mit der entsprechenden Gruppierungsvariable als Argument, wird im Output bereits angezeigt wie viele verschiednen Gruppen erstellt wurden.\n\ndata_ramen %&gt;%\n  group_by(brand) %&gt;%\n  glimpse()\n\nRows: 2,577\nColumns: 6\nGroups: brand [355]\n$ review  &lt;int&gt; 2580, 2579, 2578, 2577, 2576, 2575, 2574, 2573, 2572, 2571, 25‚Ä¶\n$ brand   &lt;chr&gt; \"New Touch\", \"Just Way\", \"Nissin\", \"Wei Lih\", \"Ching's Secret\"‚Ä¶\n$ variety &lt;chr&gt; \"T's Restaurant Tantanmen \", \"Noodles Spicy Hot Sesame Spicy H‚Ä¶\n$ style   &lt;chr&gt; \"Cup\", \"Pack\", \"Cup\", \"Pack\", \"Pack\", \"Pack\", \"Cup\", \"Tray\", \"‚Ä¶\n$ country &lt;chr&gt; \"Japan\", \"Taiwan\", \"USA\", \"Taiwan\", \"India\", \"South Korea\", \"J‚Ä¶\n$ stars   &lt;dbl&gt; 3.75, 1.00, 2.25, 2.75, 3.75, 4.75, 4.00, 3.75, 0.25, 2.50, 5.‚Ä¶\n\n\nso wurden im obigen Beispiel 355 verschiedene Gruppen gebildet, woraus wir schlie√üen k√∂nnen, dass im Datensatz 355 verschiedene Marken enthalten sind (unter der Annahme, dass keine Duplikate enthalten sind).\n\n\nDer summarise Befehl wird dann verwendet, um verschiedene Deskriptive Statistiken auf den Gruppen anzuwenden. In diesem Fall wird √§hnlich wie bei der Verwendung der mutate Funktion eine neue Spalte num_vars erstellt welch in jeder Zeile den Output der Funktion n enth√§lt. Die dplyr::n Funktion hat als R√ºckgabewert die Gruppengr√∂√üe.\n\n\n\n\n1.3.4 Faktor Variablen\nEin wichtiger Datentyp, der sowohl ordinale (Daten mit einem gewissen Ordnungsbegriff) als auch nominale Daten verarbeiten kann, sind so genannte Faktor Variablen (Datentyp &lt;fct&gt;).\nBetrachten wir hierf√ºr den folgenden Synthetischen Datensatz mit sieben Personen mit entsprechenden Altersgruppen und Augenfarben.\n\ndata_example &lt;- tibble(\n names = c(\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Eve\", \"Frank\", \"Grace\"),\n age_groups = c(\"18-25\", \"&lt;18\", \"26-35\", \"36-45\", \"18-25\", \"60+\", \"26-35\"),\n eye_color = c(\"Blue\", \"Brown\", \"Green\", \"Hazel\", \"Brown\", \"Blue\", \"Green\")\n)\n\ndata_example \n\n# A tibble: 7 √ó 3\n  names   age_groups eye_color\n  &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;    \n1 Alice   18-25      Blue     \n2 Bob     &lt;18        Brown    \n3 Charlie 26-35      Green    \n4 Diana   36-45      Hazel    \n5 Eve     18-25      Brown    \n6 Frank   60+        Blue     \n7 Grace   26-35      Green    \n\n\nDa die Variable age_group nur eine Altersspanne angibt, ist es nicht sinnvoll, sie als Zahl und nicht als Ordinalvariable zu kodieren. Mit der Funktion mutate k√∂nnen wir deshalb die Altersgruppen als Ordinalvariablen (ordered factors) kodiert werden. Dazu wird die Variable age_groups in einen Faktor mit Stufen und Label gesetzt. Die Stufen geben die Reihenfolge der Werte an, und die Label k√∂nnen zur Umbenennung dieser Kategorien verwendet werden.\n\ndata_example &lt;- data_example %&gt;%\n  mutate( \n    age_groups = factor(\n      age_groups,\n      levels = c(\"&lt;18\", \"18-25\", \"26-35\", \"36-45\", \"60+\"),\n      ordered = TRUE,\n      labels = c(\"child\",\"adult\",\"adult\",\"adult\",\"senior\")\n    )\n  )\n\n\n√Ñhnlich wie im vorherigen Beispiel sollten wir angeben, dass wir den Datensatz data_example mit einer ver√§nderten Version √ºberschreiben.\nIn der zweiten Zeile wird dann die mutate Funktion aufgerufen um in der dritten Zeile die Variabele age_groups zu √ºberschreiben.\nDurch das Setzen von age_groups = factor(age_groups, ...) wird die Variable age_groups in einen (bisher ungeordneten) Faktor umgewandelt, der das setzen von Stufen (levels) und Labels erm√∂glicht.\nSo wird durch das Setzen von levels = c(\"&lt;18\", \"18-25\",...) eine Ordnung auf die Variable auferlegt.\nordered=TRUE gibt an, dass die Altersgruppen nach den im levelsVektor angegebenen Stufen aufsteigend sortiert sind.\nZu guter Letzt gibt labels = c(\"child\", \"adult\", ...) die Bezeichnungen an, welche die numerischen Altersgruppen ersetzen. Zum Beispiel wird \\(&lt;18\\) als \"child\" bezeichnet, die Bereiche 18-25, 26-35 und 36-45 als ‚Äúadult‚Äú, und &gt;60 als \"senior\".\n\nAnalog kann auch die Variable eye_color in eine nominale Faktorvariable umgewandelt werden:\n\ndata_example &lt;- data_example %&gt;%\n  mutate(\n    eye_color = factor(eye_color)\n  )",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>(Kurz)Einf√ºhrung in R</span>"
    ]
  },
  {
    "objectID": "01_Einfuehrung.html#datenvisualisierung-mit-ggplot2",
    "href": "01_Einfuehrung.html#datenvisualisierung-mit-ggplot2",
    "title": "1¬† (Kurz)Einf√ºhrung in R",
    "section": "1.4 Datenvisualisierung mit {ggplot2}",
    "text": "1.4 Datenvisualisierung mit {ggplot2}\nEin weiterer wichtiger Aspekt des Data Minings ist die grafische Darstellung von Datens√§tzen. Die Beschreibung eines Algorithmus mit mathematischer Notation oder die Untersuchung eines Datensatzes mit Hilfe von deskriptiven und induktiven Statistiken allein kann eine Herausforderung f√ºr die Vermittlung von Botschaften darstellen. Obwohl R einige Basisfunktionen zur Erstellung von Grafiken bietet, wird in diesem Kurs haupts√§chlich die Bibliothek {ggplot2} verwendet. Eine umfassende Einf√ºhrung in {ggplot2} findet sich in Hadley Wickhams Buch Elegant Graphics for Data Analysis.\nF√ºr das folgende Beispiel wird der Datensatz data_ramen_ratings verwendet:\n\ndata_ramen_ratings &lt;- data_ramen %&gt;%\n  group_by(stars) %&gt;%\n  summarise(count=n())\n\ndata_ramen_ratings %&gt;% head()\n\n# A tibble: 6 √ó 2\n  stars count\n  &lt;dbl&gt; &lt;int&gt;\n1  0       26\n2  0.1      1\n3  0.25    11\n4  0.5     14\n5  0.75     1\n6  0.9      1\n\n\nHierbei wird ein neuer Datensatz erzeugt, welcher zwei Spalten enth√§lt. Die erste Spalte enth√§lt die verschiedenen Auspr√§gungen der Variable stars und die zweite Spalte count enth√§lt die Anzahl der Ramen, welche die entsprechende Bewertung in stars haben. Der head Befehl gibt hierbei die ersten 6 Eintr√§ge des neu erstellten Datensatzes aus.\nEine mit {ggplot2} erstellte Grafik besteht aus den folgenden drei Grundkomponenten:\n\nDie Daten selbst.\n\nggplot(data = data_ramen_ratings)\n\n\n\n\n\n\n\n\nBeachte, dass das Diagramm so noch keine Achsen, Ticks und Variablen anzeigt.\nEine Reihe von √Ñsthetik-Zuordnungen (aesthetics mappings), die beschreiben, wie Variablen in den Daten auf visuelle Eigenschaften abgebildet werden.\n\nggplot(aes(x=stars,y=count), data = data_ramen_ratings)\n\n\n\n\n\n\n\n\nDie aes Funktion gibt hierbei die √Ñsthetik-Zuordnung an. Im obigen Beispiel wird spezifiziert, dass die \\(x\\)-Achse die Variable stars abbildet und die \\(y\\)-Achse die Anzahl der Bewertungen.\nAls n√§chstes werden durch die geom-Layer die grafischen Komponenten hinzugef√ºgt, welche beschreiben wie die Daten in der Grafik repr√§sentiert werden.\n\nggplot(aes(x=stars, y=count), data = data_ramen_ratings)+\n  geom_col()\n\n\n\n\n\n\n\n\nNeben der ggplot Funktion wurde in der Obigen Zelle nun die Geometrie Column (S√§ule) hinzugef√ºgt. Um eine neue Geometrie hinzuzuf√ºgen wird nicht wie bei den vorheringen Beispielen der Pipe Operator, sondern ein + verwendet. Der Funktion geom_col (Geometry Column) wurde kein weiteres Argument hinzugef√ºgt. Man kann durch das Hinzuf√ºgen weiterer Argumente wie zum Beispiel fill (F√ºllung) die Farbe der S√§ulen ver√§ndern. So wird durch das Setzen von `fill=‚Äúred‚Äù die Farbe der S√§ulen auf rot gesetzt.\n\nggplot(aes(x=stars, y=count), data = data_ramen_ratings)+\n  geom_col(fill=\"red\")\n\n\n\n\n\n\n\n\nWeitere M√∂glichkeiten die Grafiken anzupassen und die Daten auf verschiedene Arten darzustellen werden in den folgenden √úbungen eingef√ºhrt.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>(Kurz)Einf√ºhrung in R</span>"
    ]
  },
  {
    "objectID": "01_Einfuehrung.html#√ºbungsaufgaben",
    "href": "01_Einfuehrung.html#√ºbungsaufgaben",
    "title": "1¬† (Kurz)Einf√ºhrung in R",
    "section": "1.5 √úbungsaufgaben",
    "text": "1.5 √úbungsaufgaben",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>(Kurz)Einf√ºhrung in R</span>"
    ]
  },
  {
    "objectID": "01_Einfuehrung.html#session-info",
    "href": "01_Einfuehrung.html#session-info",
    "title": "1¬† (Kurz)Einf√ºhrung in R",
    "section": "1.6 Session Info",
    "text": "1.6 Session Info\nDie Funktion sessionInfo() erfasst detaillierte Informationen √ºber die aktuelle R-Sitzung, einschlie√ülich der Version von R und der geladenen Pakete. Dies ist n√ºtzlich, um die Reproduzierbarkeit von Analysen und die Fehlersuche im Code sicherzustellen, da es eine Momentaufnahme der Umgebung liefert, in der der Code ausgef√ºhrt wurde.\n\nsessionInfo()\n\nR version 4.2.3 (2023-03-15 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 22631)\n\nMatrix products: default\n\nlocale:\n[1] LC_COLLATE=German_Germany.utf8  LC_CTYPE=German_Germany.utf8   \n[3] LC_MONETARY=German_Germany.utf8 LC_NUMERIC=C                   \n[5] LC_TIME=German_Germany.utf8    \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] lubridate_1.9.3 forcats_1.0.0   stringr_1.5.1   dplyr_1.1.4    \n [5] purrr_1.0.2     readr_2.1.5     tidyr_1.3.1     tibble_3.2.1   \n [9] ggplot2_3.5.1   tidyverse_2.0.0\n\nloaded via a namespace (and not attached):\n [1] compiler_4.2.3    pillar_1.9.0      tools_4.2.3       digest_0.6.35    \n [5] timechange_0.3.0  jsonlite_1.8.8    evaluate_1.0.1    lifecycle_1.0.4  \n [9] gtable_0.3.5      pkgconfig_2.0.3   rlang_1.1.3       cli_3.6.2        \n[13] rstudioapi_0.17.1 yaml_2.3.8        xfun_0.43         fastmap_1.1.1    \n[17] janitor_2.2.0     withr_3.0.2       knitr_1.43        generics_0.1.3   \n[21] vctrs_0.6.5       htmlwidgets_1.6.4 hms_1.1.3         grid_4.2.3       \n[25] tidyselect_1.2.1  snakecase_0.11.1  glue_1.6.2        R6_2.5.1         \n[29] fansi_1.0.4       rmarkdown_2.28    farver_2.1.1      tzdb_0.4.0       \n[33] magrittr_2.0.3    scales_1.3.0      htmltools_0.5.8.1 colorspace_2.1-0 \n[37] labeling_0.4.3    utf8_1.2.3        stringi_1.8.3     munsell_0.5.1",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>(Kurz)Einf√ºhrung in R</span>"
    ]
  }
]