[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Machine Learning Supplementary Material",
    "section": "",
    "text": "Preface\nThis (exercise) manuscript supplements the lecture notes provided for Prof. Dr. Yarema Okhrin’s lecture Machine Learning at the University of Augsburg.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#what-this-manuscript-is",
    "href": "index.html#what-this-manuscript-is",
    "title": "Machine Learning Supplementary Material",
    "section": "What this manuscript is",
    "text": "What this manuscript is\nThe manuscript intends to provide more context to different areas usually neglected in lecture and exercise sessions. The exercise sessions can especially suffer from an imbalance between repeating the theoretical aspects of the lecture and applying the concepts thoroughly. Moreover, this manuscript is comprehensive, containing every exercise and solution presented in the exercise sessions. The solutions will be more detailed than the ones presented in the in-person sessions, which can help you prepare for the exam.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#what-this-manuscript-isnt",
    "href": "index.html#what-this-manuscript-isnt",
    "title": "Machine Learning Supplementary Material",
    "section": "What this manuscript isn’t",
    "text": "What this manuscript isn’t\nThe manuscript is not a replacement for the lecture and exercise sessions. This manuscript especially lacks is the interaction between the students and lecturers which is an important aspect of the in-person exercise sessions.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#structure-of-the-manuscript",
    "href": "index.html#structure-of-the-manuscript",
    "title": "Machine Learning Supplementary Material",
    "section": "Structure of the manuscript",
    "text": "Structure of the manuscript\nDepending on the complexity of the topic, each chapter starts with a more or less technical summary and motivation. Following these summaries there will be examples that feature functions and concepts needed for the exercises. The exercises and solutions can be found subsequent to these examples.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "01_prerequisites.html",
    "href": "01_prerequisites.html",
    "title": "1  Important R concepts",
    "section": "",
    "text": "1.1 Setting up R",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Important R concepts</span>"
    ]
  },
  {
    "objectID": "01_prerequisites.html#setting-up-r",
    "href": "01_prerequisites.html#setting-up-r",
    "title": "1  Important R concepts",
    "section": "",
    "text": "1.1.1 Installing R, RStudio, and getting started with Quarto\nBefore starting the revision, we need to ensure that R and RStudio are installed. The installation process for both R and RStudio is straightforward and user-friendly. While R (the programming language) comes with a preinstalled graphical user interface, we will use the integrated development environment RStudio instead, as it looks more appealing and provides some features RGui lacks. It is important to note that in order to get RStudio to work, R needs to be installed first.\n\nR (for Windows) can be downloaded here.\nRStudio can be downloaded here.\n\nAfter successfully installing R and RStudio, starting the latter should open a window that somewhat looks like the following (cf. RStudio User Guide).\n\n\n\n\n\nThe Source pane displays a .R file named ggplot2.R. While .R files are the standard file format for R scripts used for programming in R, we will use Quarto documents (files ending with .qmd). Quarto labels itself as the\n\nnext-generation version of R Markdown,\n\nmeaning that a Quarto document allows\n\nweaving together narrative text and code to produce elegantly formatted output as documents, web pages, books, and more.\n\nQuarto is preinstalled in RStudio, so creating such documents is relatively simple.\n\nclick on New File -&gt; Quarto Document... in the File tab \nOnce the New Quarto Document window opens, you can modify the title and specify the output format. For the sake of simplicity, we will use the HTML output format. However, you could also choose PDF if you have a LaTeX installation on your device. Clicking on the create button will create a new Quarto Document. \nThe source pane now displays a sample Quarto document that can be modified. You might have to install rmarkdown (cf. mark 1). The Quarto document can then be modified by clicking on the respective sections. R Code cells can be executed by clicking on the green arrow (cf. mark 2). To insert new R code cells between paragraphs, click on the Insert tab and select Executable Cell -&gt; R (cf. mark 3).\n\n\n\n\n\n\nThis should be enough to get you started with Quarto Documents. For further reading, I recommend the Quarto Guide.\n\n\n\n\n\n\nTip\n\n\n\n\nWhile solving the (programming) exercises, you can create a new paragraph using # for a new chapter to make your document more readable. Additionally, you can simply create a section using ##.\nWriting down some details on how you approached the programming exercises in a paragraph above or below can help you understand your approach when repeating the exercises later.\n\n\n\n\n\n1.1.2 Working directories and projects\nAfter opening RStudio, execute the getwd() command in the console pane, which returns the current working directory. The working directory displays the directory of the R process. For example, if the return value of the getwd() command is C:\\Users\\lachlinu\\Desktop\\ML, then R can access any file in the ML directory. One way to change the working directory is using the setwd() command, which changes the current working directory. Manually changing the directory in every .qmd document might become tedious after a while, so a more practical alternative is setting up a project. RStudio projects allow the creation of an individual working directory for multiple contexts. For example, you might use R not only for solving Machine Learning exercises but also for your master’s thesis. Then, setting up two different projects will help you organize working directories and workspaces for each project individually. To set up a project for this course\n\nGo to the File tab and select New Project....\n\n\n\n\n\nChoose Existing Directory and navigate to the directory in which you want to create the project in and click the Create Project button.\n\n\n\n\n\nYou can now open the project by double clicking on the icon which should open a new RStudio window.\n\n\n\n\n\n\nOnce the project is opened, running the getwd() command in the console pane returns its path. Any file in this directory can be directly accessed without specifying the preceding path.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Important R concepts</span>"
    ]
  },
  {
    "objectID": "01_prerequisites.html#help-my-code-doesnt-do-what-i-expect-it-to-do",
    "href": "01_prerequisites.html#help-my-code-doesnt-do-what-i-expect-it-to-do",
    "title": "1  Important R concepts",
    "section": "1.2 Help, my code doesn’t do what I expect it to do!",
    "text": "1.2 Help, my code doesn’t do what I expect it to do!\nDebugging, also known as finding out why code does not behave as expected, plays a substantial role in programming. Even after years of practice, occasional bugs will occur. There are several more or less effective approaches to resolve problems that might occur in the context of this course, with debugging being a key focus.\n\nA simple Google search can do wonders. Most questions that arise in the context of this lecture have probably been asked on boards like Stack Overflow. Alternatively, the search results might contain websites like DataCamp or GeeksforGeeks, which will most likely answer your question as well.\nUsing a large language model like ChatGPT. When it comes to debugging or coding questions in general, large language models are helpful. Enter your question as a prompt and the answer will likely help you. However, when using less popular libraries, the answers might contain hallucinations that make it much more difficult to resolve your problem.\nThe internal help function, while it might be considered old-school, is a highly effective troubleshooting approach. It can provide valuable insights when a function doesn’t behave as expected. If a function doesn’t behave as expected, typing ?function_name in the console pane opens the respective help page. The Arguments section of the help page explains the different input parameters of a function. The Value section describes what the function intends to return. Examples of how to use a function are provided in the last section of the help.\nIf each of the steps above fails, you can also ask questions via mail. When reporting a problem via mail, it’s crucial to provide some context and the steps you’ve tried to solve it yourself. This information is invaluable in understanding the issue and providing an effective solution. Also, as part of the learning process, try solving the problems first since that is one of the most essential skill sets to develop.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Important R concepts</span>"
    ]
  },
  {
    "objectID": "01_prerequisites.html#working-with-datasets",
    "href": "01_prerequisites.html#working-with-datasets",
    "title": "1  Important R concepts",
    "section": "1.3 Working with datasets",
    "text": "1.3 Working with datasets\nIn the context of machine learning, data builds the foundation. Whether you want to predict the weather, future stock prices, or the base rent of a potential rental apartment, without high-quality data, even the most advanced models fail. However, the reality is that data we gather from the web, servers, or spreadsheets is often far from pristine. For example, missing values could be encoded as NA (Not Available), NaN (Not a Number), NULL, or simply by an empty string \" \". That is why knowing your way around basic data manipulation is essential.\n\n1.3.1 Importing data\nTo manipulate data, we first need to import it. R has quite a few preinstalled data sets; however, I prefer data sets that are either more complex, related to everyday life, or just more fun to explore. This course will provide most of the data in .csv or .txt files. Before we can start manipulating data, it’s essential to import it correctly. This ensures that the data is in the right format for further analysis.\nConsider the Netflix Movies and TV Shows data set, which can be downloaded from the data science community website Kaggle or directly below.\n\nDownload Netflix Data\n\nOnce you have downloaded the data and placed it in your current working directory, you can import it using the read.csv command:\n\ndata_netflix &lt;- read.csv(\"netflix_titles.csv\")\n\n\n\n\n\n\n\nPro Tip\n\n\n\nTo maintain structure in your project folder, it is advisable to create a separate directory for the data and import it from there. For example, if the project directory contains a data directory with the netflix_title.csv file inside, it can be imported using\n\ndata_netflix &lt;- read.csv(\"data/netflix_titles.csv\")\n\n\n\n\n\n1.3.2 Essential functions and libraries\nOne of the most versatile and essential collection of libraries in the context of data science with R is the {tidyverse} library, which includes\n\n{ggplot} for creating beautiful graphics,\n{dplyr} for data manipulation,\n{stringr} for working with strings, and\n{tibble} for storing data effectively.\n\nAn excellent in-depth introduction to the tidyverse called R for Data Science is freely available online if that piques your interest. This introduction focuses on a few core functions that will be useful throughout the course. As every other library, {tidyverse} can be attached using the library function once it has been installed:\n\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n\nOnce the library has been added, every function contained is available. For example, the glimpse function can be used on the data_netflix data set to get a short overview of the data types and contents:\n\nglimpse(data_netflix)\n\nRows: 8,807\nColumns: 12\n$ show_id      &lt;chr&gt; \"s1\", \"s2\", \"s3\", \"s4\", \"s5\", \"s6\", \"s7\", \"s8\", \"s9\", \"s1…\n$ type         &lt;chr&gt; \"Movie\", \"TV Show\", \"TV Show\", \"TV Show\", \"TV Show\", \"TV …\n$ title        &lt;chr&gt; \"Dick Johnson Is Dead\", \"Blood & Water\", \"Ganglands\", \"Ja…\n$ director     &lt;chr&gt; \"Kirsten Johnson\", \"\", \"Julien Leclercq\", \"\", \"\", \"Mike F…\n$ cast         &lt;chr&gt; \"\", \"Ama Qamata, Khosi Ngema, Gail Mabalane, Thabang Mola…\n$ country      &lt;chr&gt; \"United States\", \"South Africa\", \"\", \"\", \"India\", \"\", \"\",…\n$ date_added   &lt;chr&gt; \"September 25, 2021\", \"September 24, 2021\", \"September 24…\n$ release_year &lt;int&gt; 2020, 2021, 2021, 2021, 2021, 2021, 2021, 1993, 2021, 202…\n$ rating       &lt;chr&gt; \"PG-13\", \"TV-MA\", \"TV-MA\", \"TV-MA\", \"TV-MA\", \"TV-MA\", \"PG…\n$ duration     &lt;chr&gt; \"90 min\", \"2 Seasons\", \"1 Season\", \"1 Season\", \"2 Seasons…\n$ listed_in    &lt;chr&gt; \"Documentaries\", \"International TV Shows, TV Dramas, TV M…\n$ description  &lt;chr&gt; \"As her father nears the end of his life, filmmaker Kirst…\n\n\nRows: 8,807 means that the data set has 8,807 entries, and Columns: 12 means that the data set has 12 variables, respectively. The first column presents the variable names, their data types, and some initial values, providing a clear structure to the data set. We can already see that except for one variable (release_year), every other variable is of type chr, which stands for character or string.\n\n1.3.2.1 Filtering, grouping, and summarizing data sets\nFunctions frequently encountered while working with data are filter, group_by, and summarise. Let’s say we want to find out, according to the data set, how many movies and series were released in each year following 2010. Now, if we were to tackle this problem without the {tidyverse} framework, our code might look a little something like this:\n\nnetflix_filtered &lt;- data_netflix[data_netflix$release_year &gt; 2010, ]\nresult &lt;- aggregate(rep(1, nrow(netflix_filtered)), \n                    by = list(netflix_filtered$release_year), \n                    FUN = sum)\ncolnames(result) &lt;- c(\"release_year\", \"n\")\nresult\n\n   release_year    n\n1          2011  185\n2          2012  237\n3          2013  288\n4          2014  352\n5          2015  560\n6          2016  902\n7          2017 1032\n8          2018 1147\n9          2019 1030\n10         2020  953\n11         2021  592\n\n\nor this:\n\nnetflix_filtered &lt;- data_netflix[data_netflix$release_year &gt; 2010, ]\nresult &lt;- as.data.frame(table(netflix_filtered$release_year))\ncolnames(result) &lt;- c(\"release_year\", \"n\")\nresult\n\n   release_year    n\n1          2011  185\n2          2012  237\n3          2013  288\n4          2014  352\n5          2015  560\n6          2016  902\n7          2017 1032\n8          2018 1147\n9          2019 1030\n10         2020  953\n11         2021  592\n\n\nThe first code cell seems much more complicated than the second, yet it returns the same result. However, things can be simplified even more using the {dplyr} library that is contained in the {tidyverse}:\n\nnetflix_filtered &lt;- data_netflix %&gt;%\n  filter(release_year&gt;2010) %&gt;%\n  group_by(release_year) %&gt;%\n  summarise(n= n())\n\nLet us break down the code snippet above:\n\nIn line 1 we use the pipe operator %&gt;%. It is part of the {magrittr} package and forwards an object into a function of call expression. Figuratively, a pipe does precisely what is expected: channel an object from one and to another. In this case, the pipe operator %&gt;% passes the data_netflix data set into the filter function.\nIn line 2 the filter function selects a subset of a data set that satisfies a given condition. Here, the condition is that the movie or series’ release year should be after 2010, which is indicated by the &gt; condition.\n\n\n\n\n\n\nNote\n\n\n\nWithout the pipe operator, the first and second line can be merged into\n\nfilter(data_netflix,release_year&gt;2010)\n\nhowever, concatenating multiple functions causes the code to be unreadable and should thus be avoided.\n\n\nResults of the filtering procedure are then passed to the group_by function via the pipe operator again. The group_by function converts the underlying data set into a grouped one where operations can be performed group-wise. In the third line of the code cell, the group_by function is applied to the release_year variable, meaning that the data set now contains a group for every release year.\nThis can be seen as a pre-processing step for the summarise function applied in the following line. The summarise function creates a new data set based on the functions passed as arguments. These functions are applied to every group created by the previous step. In the example above, the function applied is n(), which returns the group size. Thus, setting n=n() as the argument creates a new column named n, which contains the number of samples within each group.\n\n\n\n\n1.3.3 Mutating data sets\nBesides filtering, grouping, and summarizing, another important concept is mutating the data, i.e., modifying the content of the data set.\nThe mutate function either creates new columns or modifies existing columns based on the passed column names and functions that are passed. It is helpful for modifying data and their types, creating new variables based on existing ones, and removing unwanted variables. In the example below, the mutate function is used to modify the variable date_added, create a new variable called is_show and delete the variable type.\n\ndata_netflix &lt;- data_netflix %&gt;% \n  mutate(date_added = mdy(date_added),\n         is_show = if_else(type==\"TV Show\",TRUE,FALSE),\n         type = NULL\n         )\n\n\nIn the first line of the code cell, the data set data_netflix is specified to be overwritten by its mutated version. Overwriting a data set is achieved by reassigning the data_netlifx object to the output of the pipe concatenation of the following code lines.\nThe original data_netflix data set is passed into the mutate function in the second line. Here, the variable date_written is overwritten by the output of the mdy function with argument date_added. The mdy function is a function in the {lubridate} library that transforms dates stored in strings to date objects that are easier to handle. Note that we can directly pass column names into functions as we have previously passed the data set into the mutate function using the %&gt;% operator.\nIn the third line, a new variable is_show is created, which takes the value TRUE, if the type of an entry in the data set is \"TV Show\" and FALSE if it is not. The if_else function achieves this.\nSetting the type variable to NULL effectively removes it from the data set.\n\n\n\n\n\n\n\nNote\n\n\n\nAssigning values in functions is achieved by using the = symbol. Assigning new variables outside of functions can also be done with the = symbol, but it is rarely used and except for some pathological cases there is no difference. However, most R users prefer assigning environment variables using &lt;- which does not work in function calls.\n\n\n\n\n\n\n\n\nPro Tip\n\n\n\nIn the previous code cell a line break was added after the %&gt;% and each argument in the mutate function for readability purposes. The code also works without adding the line breaks, but it can get messy fast:\n\ndata_netflix &lt;- data_netflix %&gt;% mutate(date_added = mdy(date_added), is_show = if_else(type==\"TV Show\",TRUE,FALSE), type = NULL)\n\n\n\n\n\n1.3.4 Factor Variables\nAn important data type that can handle both ordinal (data with some notion of order) and nominal data are so-called factor variables.\nConsider the following toy data set containing seven people with corresponding age groups and eye colors.\n\ndata_example &lt;- tibble(\n names = c(\"Alice\", \"Bob\", \"Charlie\", \"Diana\", \"Eve\", \"Frank\", \"Grace\"),\n age_groups = c(\"18-25\", \"&lt;18\", \"26-35\", \"36-45\", \"18-25\", \"60+\", \"26-35\"),\n eye_color = c(\"Blue\", \"Brown\", \"Green\", \"Hazel\", \"Brown\", \"Blue\", \"Green\")\n)\n\ndata_example \n\n# A tibble: 7 × 3\n  names   age_groups eye_color\n  &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;    \n1 Alice   18-25      Blue     \n2 Bob     &lt;18        Brown    \n3 Charlie 26-35      Green    \n4 Diana   36-45      Hazel    \n5 Eve     18-25      Brown    \n6 Frank   60+        Blue     \n7 Grace   26-35      Green    \n\n\nSince the variable age_group only specifies a range of ages, it does not make sense to encode them as integers rather than ordinal variables. The’ mutate’ function can encode age groups as ordinal variables. This involves setting the age_groups variable to a factor with levels and labels. Levels specify the order of the values, and labels can be used to rename these categories.\n\ndata_example &lt;- data_example %&gt;%\n  mutate( \n    age_groups = factor(\n      age_groups,\n      levels = c(\"&lt;18\", \"18-25\", \"26-35\", \"36-45\", \"60+\"),\n      labels = c(\"child\",\"adult\",\"adult\",\"adult\",\"senior\"),\n      ordered = TRUE\n    )\n  )\n\n\nSimilar to the previous example, we should specify that we overwrite the data_example data set with a mutated version.\nThe mutate function is applied to the age_groups variable.\nSetting age_groups = factor(age_groups, ...) converts the age_groups column into a (so far unordered) factor, allowing for specific levels (categories) and labels.\nlevels = c(\"&lt;18\", \"18-25\",...) specifies the predefined levels for the age groups.\nordered=TRUE specifies that the age groups are ordered according to the specified levels.\nLast but not least, labels = c(\"child\", \"adult\", ...) specifies the labels that replace the numeric age groups. For instance, &lt;18 is labeled as \"child\", the ranges 18-25, 26-35, and 36-45 are labeled as \"adult\", and 60+ is labeled as \"senior\".\n\nSimilarly, the variable eye_color can also be converted to a nominal factor variable:\n\ndata_example &lt;- data_example %&gt;%\n  mutate(\n    eye_color = factor(eye_color)\n  )\n\nTo confirm that the variable age_group is indeed ordered, calling the feature shows the ordered levels:\n\ndata_example$age_groups\n\n[1] adult  child  adult  adult  adult  senior adult \nLevels: child &lt; adult &lt; senior",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Important R concepts</span>"
    ]
  },
  {
    "objectID": "01_prerequisites.html#visualizing-data-with-ggplot",
    "href": "01_prerequisites.html#visualizing-data-with-ggplot",
    "title": "1  Important R concepts",
    "section": "1.4 Visualizing data with ggplot",
    "text": "1.4 Visualizing data with ggplot\nAnother critical aspect of data science and machine learning is graphical storytelling. Describing an algorithm strictly using mathematical notation or exploring a data set using descriptive and inductive statistics alone can make it challenging to understand the message. While R offers some base functions for creating graphics, this course primarily uses the library {ggplot2}. A comprehensive introduction to {ggplot2} can be found in Hadley Wickham’s book Elegant Graphics for Data Analysis. A short summary can be found below.\nFor the following example, we will use the netflix_filtered data set (see Section 1.3.2.1)\nA graphic created with {ggplot2} consists of the following three base components:\n\nThe data itself.\n\nggplot(data = netflix_filtered)\n\n\n\n\n\n\n\n\nNote, that the plot does not show any axis, ticks, and variables.\nA set of aesthetics mappings that describe how variables in the data are mapped to visual properties.\n\nggplot(aes(x=release_year, y=n), data = netflix_filtered)\n\n\n\n\n\n\n\n\nUsing the aes function, we have specified that the release year should be mapped to the \\(x\\)-axis, and \\(n\\) to the \\(y\\)-axis.\nLastly, the geom-layer (component) describes how each observation in the data set is represented.\n\nggplot(aes(x=release_year, y=n), data = netflix_filtered)+\n  geom_col()+\n  geom_point()+\n  geom_line()\n\n\n\n\n\n\n\n\nCompared to the previous two code cells, a lot is going on here. So, let us break it down.\n\nThe plus at the end of line 1 is used to add another layer.\ngeom_col adds a column chart to the canvas, creating columns starting at 0 and ending at \\(n\\). Then, + indicates that another layer is added.\ngeom_point represents the data as points on the plane, i.e., an \\(x\\) and \\(y\\)-coordinate. The + indicates that yet another layer is added afterward.\nLastly, the geom_line function adds a line connecting each data point with the one following.\n\n\n\n\n\n\n\nPro Tips\n\n\n\n\nAs before, the data set can also directly be piped into the ggplot function:\n\nnetflix_filtered %&gt;%\nggplot(aes(x=release_year, y=n))+\n geom_col()+\n geom_point()+\n geom_line()\n\nBy changing the order of the layers, you can specify which layer should be added first and last. In this example, since geom_col was added first and every other layer is placed on top of the column plot.\n\n\n\n\nThere are a lot more functions and settings that can be applied to each function. A selection of those is discussed in the exercises.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Important R concepts</span>"
    ]
  },
  {
    "objectID": "01_prerequisites.html#exercises",
    "href": "01_prerequisites.html#exercises",
    "title": "1  Important R concepts",
    "section": "1.5 Exercises",
    "text": "1.5 Exercises\nThroughout the exercises, we will work with the Credit Card Customers data set that can either be downloaded using the provided link or the button below.\n\nDownload BankChurners\n\nThe data set consists of 10,127 entries that represent individual customers of a bank including but not limited to their age, salary, credit card limit, and credit card category.\n\n1.5.1 Statistical Data Exploration and Manipulation\nWe will start by getting a feeling for the data and performing some basic data manipulation steps.\n\nExercise 1.1 Import the data set and use the glimpse function to generate a summary of the data set.\n\n\nExercise 1.2 Assume that the data set has been imported and saved as an object called credit_info. Explain the following code snippet both syntactically and semantically. Hint: Use the help function for any function you do not know.\n\ncredit_info %&gt;%\n  select_if(is.character) %&gt;%\n  sapply(table)\n\n$Attrition_Flag\n\nAttrited Customer Existing Customer \n             1627              8500 \n\n$Gender\n\n   F    M \n5358 4769 \n\n$Education_Level\n\n      College     Doctorate      Graduate   High School Post-Graduate \n         1013           451          3128          2013           516 \n   Uneducated       Unknown \n         1487          1519 \n\n$Marital_Status\n\nDivorced  Married   Single  Unknown \n     748     4687     3943      749 \n\n$Income_Category\n\n       $120K +    $40K - $60K    $60K - $80K   $80K - $120K Less than $40K \n           727           1790           1402           1535           3561 \n       Unknown \n          1112 \n\n$Card_Category\n\n    Blue     Gold Platinum   Silver \n    9436      116       20      555 \n\n\n\n\nExercise 1.3 Overwrite the variables Income_Category and Education_Level into ordered factors. When setting the levels for each group, set \"Unknown\" as the lowest level. Use this cleaned data set for the remaining exercises.\n\n\nExercise 1.4 Group the data set by income category and find out each group’s mean and median credit limit.\n\n\nExercise 1.5 Which income group has the highest mean credit limit?\n\n\nExercise 1.6 Use the following code snippet to modify the data set by incorporating it into the mutate function. The snippet converts all \"Unknown\" values contained in character or factor columns into NA values, which are easier to handle.\n\nacross(where(~ is.character(.) | is.factor(.)),\n       ~na_if(.,\"Unknown\"))\n\n\n\nExercise 1.7 Apply the na.omit() function to the data set to remove all samples in the data set that contain NA values. How many samples have been removed in total?\n\nSometimes, we only want to infer results for specific subgroups. The Blue Credit Card is the most common type of credit card. Gaining insights for this particular group allows us to retrieve information that might be useful in later analyses.\n\nExercise 1.8 Find out how many customers have a Blue credit card.\n\n\nExercise 1.9 Create a new data set credit_info_blue containing all customers that hold a Blue credit card.\n\n\nExercise 1.10 Find the number of female customers holding the Blue Card who are, at most, 40 years old and have a credit limit above 10,000 USD.\n\n\n\n1.5.2 Visual Data Exploration\n\nExercise 1.11 We now want to explore some of the demographics in our data set. Create a histogram for the age of the customers using the geom_histogram function. Note that only one variable is required for the aesthetics to create a histogram.\n\n\nExercise 1.12 Using the default parameters in the geom_histogram function, the message “stat_bin() using bins = 30. Pick better value with binwidth.” is displayed. Modify the code so that each age gets its own bin.\n\n\nExercise 1.13 Now that the histogram looks more organized, we want to add more information. For example, by setting the fill option to Gender, we can create two overlapping histograms showing the number of male and female customers within each age group.\n\n\nExercise 1.14 Instead of visualizing the Gender as in the plot above, we now want to analyze the continuous variable Credit_Limit. Therefore, instead of a histogram, use the geom_density function that plots an estimate of the underlying probability density.\n\n\nExercise 1.15 The histograms and density plots only provide limited insight into the demographics and customer status as it is relatively complex to figure out the proportions of each group. To take this one step further, consider the following histogram, which shows the Education_Level within every bin.\n\nggplot(data = credit_info_clean, aes(Customer_Age, fill = Education_Level))+\n  geom_histogram(binwidth = 1)\n\n\n\n\n\n\n\n\nWe can use the geom_histogram function and the facet_wrap function, which generates a subplot for each group. Apply the facet_wrap function to create a subplot for each education level.\n\n\n\n1.5.3 Loss functions\nIn future exercises, different loss functions will be deployed to measure how far some regression results deviate from actual values. This exercise, therefore, briefly discusses the advantages and disadvantages of some loss functions and introduces them in R.\nData-wise, we will consider the credit_info dataset and a simple linear model that is used to predict each customer’s credit limit.\nThe following Code snippet reads the unmodified data, removes the features Total_Revolving_Bal and Avg_Open_To_Buy and trains a linear model with target variable Credit_Limit on all the remaining features. It’s important to note that the model is intentionally kept simple for demonstrative purposes, making it easier for you to grasp and apply the concepts.\nCopy the snippet into your own notebook and run it. Hint: You might have to change the path in the read.csv function to your specified data path (Exercise 2.1) and install the libraries that are attached.\n\nlibrary(tidymodels)\nlibrary(yardstick)\n\ncredit_info &lt;- read.csv(\"data/BankChurners.csv\")\n\nmodel_linear_data &lt;- credit_info %&gt;%\n  select(-c(Total_Revolving_Bal,Avg_Open_To_Buy))\n\nmodel_linear_res &lt;- linear_reg() %&gt;%\n  fit(Credit_Limit ~., data = model_linear_data) %&gt;%\n  augment(model_linear_data)\n\nThe object model_linear_res now contains our model’s original data set and predictions. Do not worry if you do not understand every line in the snippet above. We will consider training models in future exercises more thoroughly.\n\n1.5.3.1 MAE Loss\nThe first loss function we explore is the Mean Absolute Error (MAE) loss defined as\n\\[\\begin{equation*}\n  \\mathrm{MAE} := \\mathrm{MAE}(y,\\hat{y}):=\\frac{1}{n}\\sum_{i=1}^n |y_i-\\hat{y_i}|,\n\\end{equation*}\\]\nwhere \\(y=(y_1,...,y_n)\\) are target values and \\(\\hat{y}=(\\hat{y_1},...,\\hat{y_n})\\) are estimates of the target values.\n\nExercise 1.16 Briefly explain how the MAE loss can be interpreted regarding the target features scale.\n\n\nExercise 1.17 The mae loss is a function in the {yardstick} library. If not already done, install the {yardstick} library and read the help function of the mae function. Then, apply it tot the model_linear_res data set and interpret the result.\n\n\n\n1.5.3.2 (R)MSE\nAnother widely used loss function is the (Root)MeanSquareError. It is defined as\n\\[\\begin{align*}\n  \\mathrm{RMSE} &:= \\mathrm{RMSE}(y,\\hat{y}) := \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n}(y_i-\\hat{y_i})^2}\\\\\n  \\mathrm{MSE} &:= \\mathrm{MSE}(y,\\hat{y}) := \\frac{1}{n}\\sum_{i=1}^{n}(y_i-\\hat{y_i})^2\n\\end{align*}\\]\n\nExercise 1.18 Repeat the exercise Exercise 1.16 and Exercise 1.17 for the RMSE and MSE.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Important R concepts</span>"
    ]
  },
  {
    "objectID": "01_prerequisites.html#solutions",
    "href": "01_prerequisites.html#solutions",
    "title": "1  Important R concepts",
    "section": "1.6 Solutions",
    "text": "1.6 Solutions\n\nSolution 1.1 (Exercise 2.1). \n\ncredit_info &lt;- read.csv(\"data/BankChurners.csv\")\n\n\n\nSolution 1.2 (Exercise 2.2). \n\ncredit_info %&gt;%\n  select_if(is.character) %&gt;%\n  sapply(table)\n\n$Attrition_Flag\n\nAttrited Customer Existing Customer \n             1627              8500 \n\n$Gender\n\n   F    M \n5358 4769 \n\n$Education_Level\n\n      College     Doctorate      Graduate   High School Post-Graduate \n         1013           451          3128          2013           516 \n   Uneducated       Unknown \n         1487          1519 \n\n$Marital_Status\n\nDivorced  Married   Single  Unknown \n     748     4687     3943      749 \n\n$Income_Category\n\n       $120K +    $40K - $60K    $60K - $80K   $80K - $120K Less than $40K \n           727           1790           1402           1535           3561 \n       Unknown \n          1112 \n\n$Card_Category\n\n    Blue     Gold Platinum   Silver \n    9436      116       20      555 \n\n\n\nIn the first line, the data set credit_info is passed to the following line.\nThe credit_info data set is passed into the select_if function that selects columns of the data set based on some condition passed in the arguments. In this case, the condition is the is.character function, that checks, whether a column is of type chr. The results are then piped into the following line.\nIn the third line, the selected columns are passed into the sapply function, that applies a given function column wise to a data set and returns the resulting data set. Here, the table function is applied generating a contingency table of the counts for each column.\n\n\n\nSolution 1.3 (Exercise 1.3). \n\ncredit_info_clean &lt;-credit_info %&gt;%\n  mutate(Income_Category = factor(Income_Category,\n                                  levels = c(\"Unknown\",\"Less than $40K\",\n                                            \"$40K - $60K\",\"$60K - $80K\",\n                                            \"$80K - $120K\",\"$120K +\"),\n                                  ordered = TRUE),\n         Education_Level = factor(Education_Level,\n                                  levels = c(\"Unknown\",\"Uneducated\",\n                                             \"High School\",\"College\",\n                                             \"Graduate\", \"Post-Graduate\",\n                                             \"Doctorate\")\n                                  )\n         )\n\n\n\nSolution 1.4 (Exercise 1.4). \n\ncredit_info_clean %&gt;%\n  group_by(Income_Category) %&gt;%\n  summarise(\n    meanlim = mean(Credit_Limit),\n    medlim = median(Credit_Limit)\n  )\n\n# A tibble: 6 × 3\n  Income_Category meanlim medlim\n  &lt;ord&gt;             &lt;dbl&gt;  &lt;dbl&gt;\n1 Unknown           9517.   6380\n2 Less than $40K    3754.   2766\n3 $40K - $60K       5462.   3682\n4 $60K - $80K      10759.   7660\n5 $80K - $120K     15810.  12830\n6 $120K +          19717.  18442\n\n\n\n\nSolution 1.5 (Exercise 1.5). \n\ncredit_info_clean %&gt;%\n  group_by(Income_Category) %&gt;%\n  summarise(\n    mean_group = mean(Credit_Limit)\n  )\n\n# A tibble: 6 × 2\n  Income_Category mean_group\n  &lt;ord&gt;                &lt;dbl&gt;\n1 Unknown              9517.\n2 Less than $40K       3754.\n3 $40K - $60K          5462.\n4 $60K - $80K         10759.\n5 $80K - $120K        15810.\n6 $120K +             19717.\n\n\nUnsurprisingly, the highest income category also has the highest mean credit limit (19,717 USD).\n\n\nSolution 1.6 (Exercise 1.6). \n\ncredit_info_clean &lt;- credit_info_clean %&gt;%\n  mutate(across(\n    where(~ is.character(.) | is.factor(.)),\n    ~ na_if(., \"Unknown\")\n  ))\n\n\n\nSolution 1.7 (Exercise 1.7). \n\nnrow_old &lt;- nrow(credit_info_clean)\n\ncredit_info_clean &lt;- credit_info_clean %&gt;%\n  na.omit()\n\nglue::glue(\"{nrow_old-nrow(credit_info_clean)} samples were removed.\")\n\n3046 samples were removed.\n\n\n\n\nSolution 1.8 (Exercise 1.8). \n\ncredit_info_clean %&gt;%\n  group_by(Card_Category) %&gt;%\n  summarise(n=n())\n\n# A tibble: 4 × 2\n  Card_Category     n\n  &lt;chr&gt;         &lt;int&gt;\n1 Blue           6598\n2 Gold             81\n3 Platinum         11\n4 Silver          391\n\n\n\n\nSolution 1.9 (Exercise 1.9). \n\ncredit_info_blue &lt;- credit_info_clean %&gt;%\n  filter(Card_Category == \"Blue\")\n\n\n\nSolution 1.10 (Exercise 1.10). \n\ncredit_info_blue %&gt;%\n  filter(Gender == \"F\" &\n           Customer_Age &lt;= 40 &\n           Credit_Limit &gt; 10000) %&gt;%\n  count()\n\n  n\n1 7\n\n\n\n\nSolution 1.11 (Exercise 1.11). \n\nggplot(data = credit_info_clean, aes(Customer_Age))+\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\nSolution 1.12 (Exercise 1.12). \n\nggplot(data = credit_info_clean, aes(Customer_Age))+\n  geom_histogram(binwidth = 1)\n\n\n\n\n\n\n\n\n\n\nSolution 1.13 (Exercise 1.13). \n\nggplot(data = credit_info_clean, aes(Customer_Age, fill = Gender))+\n  geom_histogram(binwidth = 1)\n\n\n\n\n\n\n\n\n\n\nSolution 1.14 (Exercise 1.14). \n\nggplot(data = credit_info_clean, aes(Credit_Limit))+\n  geom_density()\n\n\n\n\n\n\n\n\n\n\nSolution 1.15 (Exercise 1.15). \n\nggplot(data = credit_info_clean,\n       aes(Customer_Age, fill = Education_Level)\n       )+\n  geom_histogram(binwidth = 1) +\n  facet_wrap(\"Education_Level\")\n\n\n\n\n\n\n\n\n\n\nSolution 1.16 (Exercise 1.16). The Mean Absolute Error (MAE) loss can be interpreted in terms of the scale of the target features because it directly measures the average absolute difference between predicted and actual target values. Thus, if the target variable is on a large scale (e.g., thousands), MAE will also be large. Conversely, for small target values, the MAE will be correspondingly smaller. This makes MAE sensitive to the scale of the target features, and it is essential to normalize or scale data if different features or targets are on very different scales to ensure the MAE provides meaningful comparisons across models or data sets.\n\n\nSolution 1.17 (Exercise 1.17). The model_linear_res data set contains the .pred column, where predictions of the linear model are saved. We can use the predictions and the outcome variable Credit_Limit to calculate the MAE.\n\nmodel_linear_res %&gt;% mae(.pred,Credit_Limit)\n\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 mae     standard       4114.\n\n\nAn MAE of 4114 indicates that on average, the predicted credit limit of a customer deviates 4114 USD.\n\n\nSolution 1.18 (Exercise 1.18). \n\nSimilar to the MAE loss, the RMSE can be interpreted in terms of the scale of the target features. It also measures the average difference between the observed and predicted values, but its unique feature is that it emphasizes outliers more. Greater distances are weighted more heavily due to the square term, thereby enhancing prediction accuracy.\n\nmodel_linear_res %&gt;% yardstick::rmse(.pred,Credit_Limit)\n\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 rmse    standard       5628.\n\n\nAn RMSE of 5628 indicates that, on average, a customer’s predicted credit limit deviates 5628 USD.\nAs for the MSE, the error units are expressed as squared terms. Therefore, the scales can not be interpreted directly. MSE is usually deployed in practice since it has some nice properties like differentiability at \\(0\\), which the MAE lacks. Moreover, MSE is easier to compute, thanks to the absence of a square root, which reduces computational time.\n\nmodel_linear_rmse &lt;- model_linear_res %&gt;% rmse(.pred,Credit_Limit) %&gt;%\n  pluck(\".estimate\")\nmodel_linear_rmse^2\n\n[1] 31676421",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Important R concepts</span>"
    ]
  },
  {
    "objectID": "01_prerequisites.html#session-info",
    "href": "01_prerequisites.html#session-info",
    "title": "1  Important R concepts",
    "section": "1.7 Session Info",
    "text": "1.7 Session Info\nThe sessionInfo() function captures detailed information about the current R session, including the version of R and loaded packages. This is useful for ensuring reproducibility of analyses and troubleshooting code, as it provides a snapshot of the environment in which the code was executed.\n\nsessionInfo()\n\nR version 4.4.0 (2024-04-24 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] yardstick_1.3.1    workflowsets_1.1.0 workflows_1.1.4    tune_1.2.1        \n [5] rsample_1.2.1      recipes_1.0.10     parsnip_1.2.1      modeldata_1.3.0   \n [9] infer_1.0.7        dials_1.2.1        scales_1.3.0       broom_1.0.5       \n[13] tidymodels_1.2.0   lubridate_1.9.3    forcats_1.0.0      stringr_1.5.1     \n[17] dplyr_1.1.4        purrr_1.0.2        readr_2.1.5        tidyr_1.3.1       \n[21] tibble_3.2.1       ggplot2_3.5.1      tidyverse_2.0.0   \n\nloaded via a namespace (and not attached):\n [1] tidyselect_1.2.1    timeDate_4032.109   farver_2.1.1       \n [4] fastmap_1.1.1       digest_0.6.35       rpart_4.1.23       \n [7] timechange_0.3.0    lifecycle_1.0.4     survival_3.5-8     \n[10] magrittr_2.0.3      compiler_4.4.0      rlang_1.1.3        \n[13] tools_4.4.0         utf8_1.2.4          yaml_2.3.8         \n[16] data.table_1.15.4   knitr_1.46          labeling_0.4.3     \n[19] htmlwidgets_1.6.4   DiceDesign_1.10     withr_3.0.0        \n[22] nnet_7.3-19         grid_4.4.0          fansi_1.0.6        \n[25] colorspace_2.1-0    future_1.33.2       iterators_1.0.14   \n[28] globals_0.16.3      MASS_7.3-60.2       cli_3.6.2          \n[31] crayon_1.5.2        rmarkdown_2.26      generics_0.1.3     \n[34] rstudioapi_0.16.0   future.apply_1.11.2 tzdb_0.4.0         \n[37] splines_4.4.0       parallel_4.4.0      vctrs_0.6.5        \n[40] hardhat_1.3.1       Matrix_1.7-0        jsonlite_1.8.8     \n[43] hms_1.1.3           listenv_0.9.1       foreach_1.5.2      \n[46] gower_1.0.1         glue_1.7.0          parallelly_1.37.1  \n[49] codetools_0.2-20    stringi_1.8.4       gtable_0.3.5       \n[52] munsell_0.5.1       GPfit_1.0-8         pillar_1.9.0       \n[55] furrr_0.3.1         htmltools_0.5.8.1   ipred_0.9-14       \n[58] lava_1.8.0          R6_2.5.1            lhs_1.1.6          \n[61] evaluate_0.23       lattice_0.22-6      backports_1.4.1    \n[64] class_7.3-22        Rcpp_1.0.12         prodlim_2023.08.28 \n[67] xfun_0.43           pkgconfig_2.0.3",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Important R concepts</span>"
    ]
  },
  {
    "objectID": "02_linear_models.html",
    "href": "02_linear_models.html",
    "title": "2  Linear Models",
    "section": "",
    "text": "2.1 Overview\nIn this exercise session, we will review linear regression and polynomial regression. We will also learn how to efficiently split our data into training and test data, how to perform cross-validation, and why that is important. Before we dive into the details, we will discuss developing statistical models in R.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linear Models</span>"
    ]
  },
  {
    "objectID": "02_linear_models.html#good-practices-for-applied-machine-learning",
    "href": "02_linear_models.html#good-practices-for-applied-machine-learning",
    "title": "2  Linear Models",
    "section": "2.2 Good practices for applied Machine Learning",
    "text": "2.2 Good practices for applied Machine Learning\nIn previous courses, we mainly focused on fitting a certain model to a given dataset. However, this process could be described as model specification rather than model development. So, what is the difference between specifying and building a model?\n\n2.2.1 Developing a model (What we have done so far!):\n\nThe given dataset has been cleaned, transformed, and manipulated using various packages and libraries.\nResampling methods (like the ones we consider today) have been applied, but training the model on each subset or newly generated dataset is usually performed using a for-loop or similar methods. Loops should mostly be avoided in programming languages like R since they can be slow compared to optimized methods specifically written for higher performance.\nSimilar to applying resampling methods, hyperparameter tuning is usually performed in the same fashion.\n\nIn summary, we have only specified the model we want to train and used a somewhat arbitrary and inconsistent approach for everything else.\nOne of the most significant issues we face, however, is when switching the model. The approach we have been using so far emphasizes working with one selected model that we wish to keep using after data preprocessing.\n\n\n2.2.2 Developing a model (What we want to do moving forward!):\nThe main difference between the old and new approaches is leveraging the advantages of the {tidyverse} and {tidymodels} frameworks. These frameworks allow for consistently preprocessing the data, setting model specifications, and performing steps like resampling and hyperparameter tuning simultaneously.\nAnother huge advantage is that we can swiftly switch between different ML models by following this procedure. For example, applying a random forest algorithm and switching to a neural network approach for the same data is only a matter of changing a few lines of code, as we will see in later exercises.\nSo, where is the catch? At first, the process might seem complicated or even “overkill” for the models we use. However, as the lecture progresses, our models will also (at least sometimes) become increasingly sophisticated. We want to get used to this new process as early as possible, as it will be useful once we consider more sophisticated models.\nThe biggest takeaways are:\n\nConsistency: Independent of what the dataset or desired model looks like, we can (almost) always use the same procedure when building a model.\nEffectiveness: Once we get used to this new approach, we can develop our models more effectively.\nSafety: Developing an ML model has many pitfalls and potholes on the way, and by design, {tidymodels} helps us to avoid those.\n\nWe will introduce and explore some of the concepts above in this session’s exercises and dive deeper in later sessions.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linear Models</span>"
    ]
  },
  {
    "objectID": "02_linear_models.html#introduction-to-model-development-with-tidymodels",
    "href": "02_linear_models.html#introduction-to-model-development-with-tidymodels",
    "title": "2  Linear Models",
    "section": "2.3 Introduction to model development with {tidymodels}",
    "text": "2.3 Introduction to model development with {tidymodels}\nThis section briefly introduces the most important concepts when working with the {tidymodels} framework.\nThe data set for this introduction is called “Wine Quality White,” and it contains roughly 5,000 different white wines tested for their physicochemical properties, such as citric acid, pH value, and density. After assessing these properties, experts rated the wine quality and assigned a score between \\(0\\) and \\(10\\), where \\(0\\) is the lowest, and \\(10\\) is the highest score a wine can achieve.\nThe data set can be downloaded directly from the UC Irvine Machine Learning Repository or by clicking the button below.\n\nDownload Wine Data\n\n\n2.3.1 Data Exploration\nSince the data set is relatively nice in that we do not have to do much cleaning, we will keep this section relatively short.\n\nlibrary(\"tidyverse\")\nlibrary(\"tidymodels\")\n\n\n\nWarning: package 'ggtext' was built under R version 4.4.1\n\n\n\ndata_wine &lt;- read.csv(\"data/winequality-white.csv\")\ndata_wine %&gt;% glimpse()\n\nRows: 4,898\nColumns: 12\n$ fixed.acidity        &lt;dbl&gt; 7.0, 6.3, 8.1, 7.2, 7.2, 8.1, 6.2, 7.0, 6.3, 8.1,…\n$ volatile.acidity     &lt;dbl&gt; 0.27, 0.30, 0.28, 0.23, 0.23, 0.28, 0.32, 0.27, 0…\n$ citric.acid          &lt;dbl&gt; 0.36, 0.34, 0.40, 0.32, 0.32, 0.40, 0.16, 0.36, 0…\n$ residual.sugar       &lt;dbl&gt; 20.70, 1.60, 6.90, 8.50, 8.50, 6.90, 7.00, 20.70,…\n$ chlorides            &lt;dbl&gt; 0.045, 0.049, 0.050, 0.058, 0.058, 0.050, 0.045, …\n$ free.sulfur.dioxide  &lt;dbl&gt; 45, 14, 30, 47, 47, 30, 30, 45, 14, 28, 11, 17, 1…\n$ total.sulfur.dioxide &lt;dbl&gt; 170, 132, 97, 186, 186, 97, 136, 170, 132, 129, 6…\n$ density              &lt;dbl&gt; 1.0010, 0.9940, 0.9951, 0.9956, 0.9956, 0.9951, 0…\n$ pH                   &lt;dbl&gt; 3.00, 3.30, 3.26, 3.19, 3.19, 3.26, 3.18, 3.00, 3…\n$ sulphates            &lt;dbl&gt; 0.45, 0.49, 0.44, 0.40, 0.40, 0.44, 0.47, 0.45, 0…\n$ alcohol              &lt;dbl&gt; 8.8, 9.5, 10.1, 9.9, 9.9, 10.1, 9.6, 8.8, 9.5, 11…\n$ quality              &lt;int&gt; 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 7, 5, 7, 6…\n\n\nExcept for the quality variable, every other variable is of type double.\n\n\n2.3.2 Training a simple linear model\nFor this example we build a linear model to predict the alcohol content of the wines. Recall the model equation \\[\\begin{equation}\n  y = \\beta_0 + \\beta_1 x_1 + ... + \\beta_n x_n + \\varepsilon,\n\\end{equation}\\]\nwhere \\(x_1,...,x_n\\in\\mathbb{R}^k\\) denotes \\(n\\) different features with \\(k\\) samples, \\(\\varepsilon \\sim \\mathcal{N}(0,1)\\) a \\(k\\)-dimensional error term and \\(\\beta_0,...,\\beta_n\\) the \\(n+1\\) model parameters. In our example, \\(y\\) denotes the variable alcohol, \\(k= 4898\\), and \\(n = 11\\).\nThe {parsnip} packages which is part of {tidymodels} contains the function linear_reg which creates a linear model when called.\n\nlm_mod &lt;- linear_reg()\nlm_mod\n\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n\n\nOnly calling the function name does not help much when trying to model the alcohol contents of the wine, since we haven’t specified the input variables, output variable, and data used for the regression.\nTo add these, we can use the %&gt;% pipe operator and fit function. As discussed in the previous exercise, the pipe operator passes the output of one operation in the other. Therefore, passing the lm_mod object into the fit function, specifies that the fit function fits a linear model. Fitting in that context refers to estimating the parameters \\(\\beta_0,...,\\beta_n\\). Besides the model specification, arguments for the fit function contain the formula which specifies the independent and dependent variables and the data argument which specifies the data that is used for training the model.\nThe formula in the code cell below specifies that we want to regress alcohol on every other variable indicated by the . after ~. ~ (tilde) is used to separate the left- and right-hand sides in the model formula.\nAs data we simply pass the whole data_wine data set.\n\nlm_mod &lt;- linear_reg() %&gt;% fit(\n formula = alcohol ~.,\n data = data_wine\n)\nlm_mod\n\nparsnip model object\n\n\nCall:\nstats::lm(formula = alcohol ~ ., data = data)\n\nCoefficients:\n         (Intercept)         fixed.acidity      volatile.acidity  \n           6.719e+02             5.099e-01             9.636e-01  \n         citric.acid        residual.sugar             chlorides  \n           3.658e-01             2.341e-01            -1.832e-01  \n free.sulfur.dioxide  total.sulfur.dioxide               density  \n          -3.665e-03             6.579e-04            -6.793e+02  \n                  pH             sulphates               quality  \n           2.383e+00             9.669e-01             6.663e-02  \n\n\nThe return value is a parsnip model object that prints the model coefficients \\(\\beta_0,...,\\beta_n\\) when called.\nInstead of fitting the linear model on all parameters using ., we can also specify the relationship between the independent variables using arithmetic notation:\n\nlm_mod &lt;- linear_reg() %&gt;% fit(\n formula = alcohol ~ fixed.acidity+volatile.acidity+citric.acid+\n   residual.sugar+chlorides+free.sulfur.dioxide+\n   total.sulfur.dioxide+density+pH+\n   sulphates+quality,\n data = data_wine\n)\n\nNote, that this notation does not fall under best practices of model development as it is more advisable to create a separate data set for training and fit the model on every variable contained using the . notation.\n\n\n2.3.3 Evaluating a model\n\n2.3.3.1 Creating a summary of the model parameters\nUsing the tidy function on the fitted model returns an overview of the model parameters including \\(p\\)-values and the \\(t\\)-statistic.\n\nlm_mod %&gt;% tidy()\n\n# A tibble: 12 × 5\n   term                    estimate std.error statistic  p.value\n   &lt;chr&gt;                      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n 1 (Intercept)           672.        5.56       121.    0       \n 2 fixed.acidity           0.510     0.00986     51.7   0       \n 3 volatile.acidity        0.964     0.0672      14.3   1.00e-45\n 4 citric.acid             0.366     0.0560       6.54  6.88e-11\n 5 residual.sugar          0.234     0.00296     79.1   0       \n 6 chlorides              -0.183     0.321       -0.571 5.68e- 1\n 7 free.sulfur.dioxide    -0.00366   0.000494    -7.42  1.33e-13\n 8 total.sulfur.dioxide    0.000658  0.000222     2.97  3.01e- 3\n 9 density              -679.        5.70      -119.    0       \n10 pH                      2.38      0.0519      45.9   0       \n11 sulphates               0.967     0.0575      16.8   1.02e-61\n12 quality                 0.0666    0.00834      7.99  1.70e-15\n\n\nRecall that the statistic column refers to the \\(t\\)-statistic which corresponds to the following hypotheses for any \\(\\hat{\\beta}_i,\\, i=1,...,12\\): \\[\\begin{equation*}\nH_0:\\, \\hat{\\beta}_i= 0\\qquad \\mathrm{vs.}\\qquad H_1:\\, \\hat{\\beta}_i \\neq 0.\n\\end{equation*}\\] If the \\(p\\)–value regarding this test is low, we can confidently reject the null hypothesis.\nSimilar to the tidy function, the summary function can be called on the fit attribute of the model, which also returns a summary which contains a few more details, such as the \\(F\\)-statistic, \\(R^2\\), and residual standard error.\n\nlm_mod$fit %&gt;% summary()\n\n\nCall:\nstats::lm(formula = alcohol ~ fixed.acidity + volatile.acidity + \n    citric.acid + residual.sugar + chlorides + free.sulfur.dioxide + \n    total.sulfur.dioxide + density + pH + sulphates + quality, \n    data = data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-3.3343 -0.2553 -0.0255  0.2214 15.7789 \n\nCoefficients:\n                       Estimate Std. Error  t value Pr(&gt;|t|)    \n(Intercept)           6.719e+02  5.563e+00  120.790  &lt; 2e-16 ***\nfixed.acidity         5.099e-01  9.855e-03   51.745  &lt; 2e-16 ***\nvolatile.acidity      9.636e-01  6.718e-02   14.342  &lt; 2e-16 ***\ncitric.acid           3.658e-01  5.596e-02    6.538 6.88e-11 ***\nresidual.sugar        2.341e-01  2.960e-03   79.112  &lt; 2e-16 ***\nchlorides            -1.832e-01  3.207e-01   -0.571  0.56785    \nfree.sulfur.dioxide  -3.665e-03  4.936e-04   -7.425 1.33e-13 ***\ntotal.sulfur.dioxide  6.579e-04  2.217e-04    2.968  0.00301 ** \ndensity              -6.793e+02  5.696e+00 -119.259  &lt; 2e-16 ***\npH                    2.383e+00  5.191e-02   45.916  &lt; 2e-16 ***\nsulphates             9.669e-01  5.751e-02   16.814  &lt; 2e-16 ***\nquality               6.663e-02  8.341e-03    7.988 1.70e-15 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.4409 on 4886 degrees of freedom\nMultiple R-squared:  0.8719,    Adjusted R-squared:  0.8716 \nF-statistic:  3024 on 11 and 4886 DF,  p-value: &lt; 2.2e-16\n\n\nTo extract these statistics in tidy fashion, the {yardsticks} library (see Exercise Session 01) can help.\n\n\n2.3.3.2 Using metric sets and glance\nInstead of using the summary function on the fit attribute to extract certain metrics, we can also use the metric_set function. First, define a metric set by passing different metrics such as rsq, rmse, and mae into the metric_set function. Then, pass the predictions of the model into this newly defined metric set which returns the specified metrics.\n\nmulti_metric &lt;- metric_set(rsq,rmse,mae)\n\nlm_mod %&gt;%\n  augment(data_wine) %&gt;%\n  multi_metric(.pred,alcohol)\n\n# A tibble: 3 × 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 rsq     standard       0.872\n2 rmse    standard       0.440\n3 mae     standard       0.294\n\n\nA general metric set can be created using the glance function which returns a comprehensive list of metrics for the underlying model.\n\nglance(lm_mod)\n\n# A tibble: 1 × 12\n  r.squared adj.r.squared sigma statistic p.value    df logLik   AIC   BIC\n      &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     0.872         0.872 0.441     3024.       0    11 -2933. 5892. 5976.\n# ℹ 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt;\n\n\n\n\n\n2.3.4 Training and test split\nSplitting the data into three different subsets, called training, validation, and testing data, is a crucial aspect in Machine Learning.\n\n\n\n\n\n\nFigure 2.1\n\n\n\nThe basic idea is to train the model on the training data, validate the results on the validation data, and finally test the performance on the testing data that has previously not been observed.\nWithout this separation the model might become prone to overfitting meaning that the model does not perform well on previously unseen data.\nThe general procedure for training and testing a model is depicted in the following figure.\n\n\n\n\n\n\nFigure 2.2: Based on this Google Developers Figure\n\n\n\nHere, the training and validation data set are used in the training procedure and the testing data set in the testing procedure.\n\n\n\n\n\n\nNote\n\n\n\nThe reevaluation during training only makes sense when changing parameters can lead to an improvement. For a simple linear regression this is not the case, since once the model parameters \\(\\beta_0,...,\\beta_n\\) are estimated, they are optimal (cf. Gauss-Markov theorem).\n\n\nA simple training and test split with \\(80\\%\\) training data and \\(20\\%\\) test data can be generated with the initial_split, training, and testing function. Before splitting the data (which is done randomly) we can set a seed. Setting a seed allows us to reproduce the outcome of our code, even when randomness is involved.\n\nset.seed(123)\ntt_split&lt;-initial_split(data_wine, 0.8)\ndata_train &lt;- tt_split %&gt;% training() \ndata_test &lt;- tt_split %&gt;% testing()\n\nTraining the linear model on the training data and evaluating it on the test data then yields\n\nlm_mod &lt;- linear_reg() %&gt;%\n  fit(\n   formula = alcohol ~.,\n   data = data_train\n  )\n\nlm_mod %&gt;%\n  augment(data_test) %&gt;%\n  multi_metric(.pred,alcohol)\n\n# A tibble: 3 × 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 rsq     standard       0.887\n2 rmse    standard       0.408\n3 mae     standard       0.307\n\n\n\n\n2.3.5 Cross validation\nA popular approach we will use in most exercises extends the procedure described in Figure Figure 2.1 and Figure Figure 2.2. Instead of using a single training and validation data set, we create multiple instances of training and validation data by randomly assigning a data point to the training or validation set. More formally, \\(v\\)-fold cross validation randomly splits the training and validation data into \\(v\\) equally sized subsets. In each iteration, one of these subsets is set aside to be the validation data, while the other \\(v-1\\) subsets are used for training. The figure below depicts how that process works for v = 5.\n\n\n\n5-fold Cross Validation\n\n\nA part of the whole data set is left as testing data. The blue boxes in the lower part of the figure contain the validation (sub)sets for each split while the training data is contained in the remaining (sub)sets.\n\n2.3.5.1 Creating a cross validation set in R\nCross validation in R can be performed using the {resample} library that is also part of the {tidymodels} framework.\nThe vfold_cv function creates a nested data frame, meaning that each entry in the data frame contains another data frame. v denotes the number of created folds and data_train specifies that the folds are created from the data_train data set.\n\nset.seed(123)\nfolds &lt;- vfold_cv(data_train, v = 5)\n\nNote, that since the folds are also created stochastically, setting a seed ensures that the results are reproducible. We can access split \\(i\\) in a fold using the $split attribute and double brackets with the respective index. Note, that each split consists of a training and validation set that can each be accessed using the analysis and assessment function respectively.\n\nfolds$splits[[1]] %&gt;% \n  analysis() %&gt;%\n  glimpse()\n\nRows: 3,134\nColumns: 12\n$ fixed.acidity        &lt;dbl&gt; 8.3, 7.7, 5.7, 7.2, 9.3, 6.6, 6.6, 9.0, 6.5, 7.2,…\n$ volatile.acidity     &lt;dbl&gt; 0.25, 0.28, 0.26, 0.24, 0.34, 0.15, 0.17, 0.22, 0…\n$ citric.acid          &lt;dbl&gt; 0.33, 0.58, 0.24, 0.29, 0.49, 0.32, 0.26, 0.49, 0…\n$ residual.sugar       &lt;dbl&gt; 2.5, 12.1, 17.8, 2.2, 7.3, 6.0, 7.4, 10.4, 1.4, 5…\n$ chlorides            &lt;dbl&gt; 0.053, 0.046, 0.059, 0.037, 0.052, 0.033, 0.052, …\n$ free.sulfur.dioxide  &lt;dbl&gt; 12, 60, 23, 37, 30, 59, 45, 52, 14, 14, 44, 37, 2…\n$ total.sulfur.dioxide &lt;dbl&gt; 72, 177, 124, 102, 146, 128, 128, 195, 99, 125, 1…\n$ density              &lt;dbl&gt; 0.99404, 0.99830, 0.99773, 0.99200, 0.99800, 0.99…\n$ pH                   &lt;dbl&gt; 2.89, 3.08, 3.30, 3.27, 3.17, 3.19, 3.16, 3.31, 3…\n$ sulphates            &lt;dbl&gt; 0.48, 0.46, 0.50, 0.64, 0.61, 0.71, 0.37, 0.44, 0…\n$ alcohol              &lt;dbl&gt; 9.5, 8.9, 10.1, 11.0, 10.2, 12.1, 10.0, 10.2, 10.…\n$ quality              &lt;int&gt; 5, 5, 5, 7, 5, 8, 6, 6, 6, 5, 5, 5, 5, 6, 7, 6, 7…\n\nfolds$splits[[1]] %&gt;%\n  assessment() %&gt;%\n  glimpse()\n\nRows: 784\nColumns: 12\n$ fixed.acidity        &lt;dbl&gt; 6.2, 5.9, 6.7, 6.0, 8.6, 6.9, 8.0, 7.2, 6.7, 5.9,…\n$ volatile.acidity     &lt;dbl&gt; 0.28, 0.32, 0.18, 0.29, 0.33, 0.21, 0.14, 0.19, 0…\n$ citric.acid          &lt;dbl&gt; 0.45, 0.39, 0.28, 0.25, 0.34, 0.24, 0.49, 0.31, 0…\n$ residual.sugar       &lt;dbl&gt; 7.50, 3.30, 10.20, 1.40, 11.80, 1.80, 1.50, 6.30,…\n$ chlorides            &lt;dbl&gt; 0.045, 0.114, 0.039, 0.033, 0.059, 0.021, 0.035, …\n$ free.sulfur.dioxide  &lt;dbl&gt; 46, 24, 29, 30, 42, 17, 42, 17, 32, 26, 50, 11, 1…\n$ total.sulfur.dioxide &lt;dbl&gt; 203, 140, 115, 114, 240, 80, 120, 103, 111, 114, …\n$ density              &lt;dbl&gt; 0.99573, 0.99340, 0.99469, 0.98794, 0.99882, 0.98…\n$ pH                   &lt;dbl&gt; 3.26, 3.09, 3.11, 3.08, 3.17, 3.15, 3.26, 3.15, 3…\n$ sulphates            &lt;dbl&gt; 0.46, 0.45, 0.45, 0.43, 0.52, 0.46, 0.40, 0.52, 0…\n$ alcohol              &lt;dbl&gt; 9.2, 9.2, 10.9, 13.2, 10.0, 12.3, 10.6, 11.4, 11.…\n$ quality              &lt;int&gt; 6, 6, 7, 6, 6, 7, 7, 7, 7, 6, 6, 4, 5, 5, 7, 8, 6…\n\n\n\n\n2.3.5.2 Training a model using cross validation\nTo train the linear model on each split, we can use the fit_resamples function. Training the model on each fold is the as simple as training he model without resamples: We simply pass the model specification, formula, and additionally the cross validation object into the fit_resamples formula. Additionally, we can also pass the metric set multi_metric to specify which metrics we want to use for model evaluation.\n\nlm_mod_resampling &lt;- linear_reg()\nlm_mod_resampling_res &lt;- fit_resamples(lm_mod_resampling,\n                            alcohol ~.,\n                            folds,\n                            metrics = multi_metric)\n\nThe return value of the fit_resamples function is a data frame containing \\(5\\) linear models (since we specified v=5 when creating the folds object).\n\nlm_mod_resampling_res\n\n# Resampling results\n# 5-fold cross-validation \n# A tibble: 5 × 4\n  splits             id    .metrics         .notes          \n  &lt;list&gt;             &lt;chr&gt; &lt;list&gt;           &lt;list&gt;          \n1 &lt;split [3134/784]&gt; Fold1 &lt;tibble [3 × 4]&gt; &lt;tibble [0 × 3]&gt;\n2 &lt;split [3134/784]&gt; Fold2 &lt;tibble [3 × 4]&gt; &lt;tibble [0 × 3]&gt;\n3 &lt;split [3134/784]&gt; Fold3 &lt;tibble [3 × 4]&gt; &lt;tibble [0 × 3]&gt;\n4 &lt;split [3135/783]&gt; Fold4 &lt;tibble [3 × 4]&gt; &lt;tibble [0 × 3]&gt;\n5 &lt;split [3135/783]&gt; Fold5 &lt;tibble [3 × 4]&gt; &lt;tibble [0 × 3]&gt;\n\n\nWe are mainly interested in the cross validation error (CV-RMSE) defined as\n\\[\\begin{equation*}\n  \\mathrm{CV-RMSE} = \\frac{1}{v}\\sum_{i=1}^v \\mathrm{RMSE}_i,\n\\end{equation*}\\]\nwhere \\(\\mathrm{RMSE}_i\\) stands for the RMSE of the \\(i\\)-th. hold-out sample.\nWe can collect this metric by applying the collect_metrics function:\n\nlm_mod_resampling_res %&gt;% collect_metrics()\n\n# A tibble: 3 × 6\n  .metric .estimator  mean     n std_err .config             \n  &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;               \n1 mae     standard   0.300     5 0.00460 Preprocessor1_Model1\n2 rmse    standard   0.451     5 0.0710  Preprocessor1_Model1\n3 rsq     standard   0.866     5 0.0414  Preprocessor1_Model1\n\n\nThe third column mean depicts the mean rmse and rsq across all the splits. Comparing the CV-RMSE (\\(0.451\\)) to the true out of sample (OOS) RMSE of the test set (\\(0.408\\)) reveals that the performance of the linear model seems stable, meaning that it is not prone to overfitting. Furthermore, the CV-RMSE seems to overestimate the true OOS RMSE, since \\(0.451&gt;0.408\\). Using this information we can make prediction about the alcohol contents of a wine with the estimated model parameters on the training data set.\n\n\n\n2.3.6 Polynomial regression and the bias variance trade off\nPolynomial regression is a special case of multiple linear regression where the model is still linear in its coefficients but the dependent variable \\(y\\) is modeled as polynomial in \\(x\\). For an \\(n\\)-th degree polynomial model the model equation is therefore given by\n\\[\\begin{equation*}\n  y = \\beta_0 + \\beta_1 x + \\beta_2 x^2 + ... + \\beta_n x^n.\n\\end{equation*}\\]\n\n\n\n\n\n\nNote\n\n\n\nFor this specific model we only use one independent variable \\(x\\) instead of \\(n\\) different independent variables \\(x_1\\),…,\\(x_n\\).\n\n\nSay, we want to model the alcohol contents of wine with a MLR model using the wine density as the only predictor.\nConsider the following synthetic dataset consisting of \\(12\\) observations.\n\nset.seed(123)\ndata_synth &lt;- tibble(\n  x = seq(0,1,1/11),\n  y = x+rnorm(12,0,0.1)\n)\n\nsplit_synth &lt;- initial_split(data_synth,0.8)\ndata_train_synth &lt;- split_synth %&gt;% training()\ndata_test_synth &lt;- split_synth %&gt;% testing()\n\ndata_synth\n\n# A tibble: 12 × 2\n        x       y\n    &lt;dbl&gt;   &lt;dbl&gt;\n 1 0      -0.0560\n 2 0.0909  0.0679\n 3 0.182   0.338 \n 4 0.273   0.280 \n 5 0.364   0.377 \n 6 0.455   0.626 \n 7 0.545   0.592 \n 8 0.636   0.510 \n 9 0.727   0.659 \n10 0.818   0.774 \n11 0.909   1.03  \n12 1       1.04  \n\n\nFrom the figure below, it is immediately evident, that a polynomial model perfectly fits the training data, but severely fails to estimate the rightmost point of the testing data. While the linear model does not fit the training data\n\n\n\n\n\n\n\n\n\nTo verify this, we can also compare the training and test error for different metrics of each model.\n\nlm_poly_mod &lt;- linear_reg() %&gt;% \n  fit(formula = y ~ poly(x, 8),\n      data = data_train_synth\n      )\n\nlm_lin_mod &lt;- linear_reg() %&gt;% \n  fit(formula = y ~ x,\n      data = data_train_synth\n      )\n\nVisualizing the difference in train and test error then yields\n\n\n\n\n\n\n\n\n\nThe example above demonstrates the phenomenon of bias-variance tradeoff. A low variance and high bias can be observed in the linear model, since there are only few (two) model parameters and a small discrepancy between training and test error. The polynomial model exhibits a large discrepancy between training and test error and since there are many (nine) parameters, indicating that it has a high variance but low bias.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linear Models</span>"
    ]
  },
  {
    "objectID": "02_linear_models.html#exercises",
    "href": "02_linear_models.html#exercises",
    "title": "2  Linear Models",
    "section": "2.4 Exercises",
    "text": "2.4 Exercises\nThroughout the exercises, we will work with a subset of the Apartment rental offers in Germany data set that can be downloaded using the button below. It contains 239 unique rental listings for flats in Augsburg which were sourced at three different dates in 2018 and 2019 and contains 28 different variables.\n\nDownload AugsburgRental\n\n\nExercise 2.1 Instead of focusing on a comprehensive data cleaning and manipulation process, we will simply use the two variables livingSpace measuring the area of living in \\(m^2\\) of a listing and baseRent in EUR, representing the monthly base rent.\nImport the data and visualize the relationship between the two variables livingSpace and baseRent with a scatter plot. Rename the axis of the plot such that they display the words base rent and living space (seperated by a whitespace).\n\n\nExercise 2.2 Without conducting a thorough outlier analysis, remove every listing that either costs more than \\(2500\\) EUR or is bigger than \\(200\\: m^2\\).\n\n\nExercise 2.3 Create a training (\\(80\\%\\)) and test data set using the filtered data. Use set.seed(2) to generate reproducible results.\n\n\nExercise 2.4 Train a simple linear model on the training data.\n\n\nExercise 2.5 Generate a model summary and interpret the coefficients. Is the independent variable statistically significant?\n\n\nExercise 2.6 Evaluate the model on the test data by considering the adjusted \\(R^2\\) and MAE. On average, how far off is the estimated base rent?\n\n\nExercise 2.7 Create a \\(10\\)-fold cross validation split of the training data using the same seed as before and retrain the simple linear model. Compare the cross validation MAE to the OOS MAE and interpret the result.\n\n\nExercise 2.8 Repeat Exercises Exercise 2.6 and Exercise 2.8 for a polynomial model of degree 20. Compare the test and cross-validation MAE of the linear model with the polynomial model.\n\n\nExercise 2.9 Create a scatter plot of the training data and insert both fitted curves using the geom_smooth function.\n\n\nExercise 2.10 Assume we have fitted a simple linear model \\[\\begin{equation*}\n  \\hat{y} = \\hat{\\beta_0}+\\hat{\\beta_1}x.\n\\end{equation*}\\]\nFor \\(\\hat\\beta_1\\) the \\(t\\)-statistic has a \\(p\\)-value of \\(1e-16\\) (\\(=1\\cdot 10^{-16}\\)). Describe the null hypothesis of the underlying test and explain what concnulision can be drawn based on this \\(p\\)-value.\n\n\nExercise 2.11 Assume we have a data set with \\(k = 400\\) containing a single independent variable \\(x\\) and a real valued dependent variable \\(y\\). We fit a simple regression model and a polynomial regression with degree \\(5\\) on \\(75\\%\\) of the data and leave the remaining \\(25\\%\\) for testing .\n\nAssume that the true relationship between \\(x\\) and \\(y\\) is linear. Consider the training RMSE for the linear regression, and also the training RMSE for the polynomial regression. Choose the most appropriate answer and justify your choice.\n1.1 The polynomial model has more flexibility due to the additional terms, so it will fit the data better than the linear model, resulting in a lower training RMSE.\n1.2 The linear model is simpler and less prone to overfitting, so it will produce a lower training RMSE compared to the polynomial model.\n1.3 Since both models are trying to explain the same data, their training RMSE should be approximately the same.\n1.4 Without knowing the true underlying relationship between the predictor and response, we cannot definitively predict the behavior of the training RMSE for either model.\nRepeat the previous exercise but instead of the training RMSE, consider the test RMSE.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linear Models</span>"
    ]
  },
  {
    "objectID": "02_linear_models.html#solutions",
    "href": "02_linear_models.html#solutions",
    "title": "2  Linear Models",
    "section": "2.5 Solutions",
    "text": "2.5 Solutions\n\nSolution 2.1 (Exercise 2.1). The data set can be imported using the read_csv function.\n\ndata_aux &lt;- read_csv(\"data/rent_aux.csv\")\n\nUsing the ggplot function, we can create a simple scatter plot. The labs function allows to define new axis labels by specifying the axis and assigning the names to the respective axis. \\(x\\) corresponds to the horizontal axis and \\(y\\) to the vertical axis.\n\ndata_aux %&gt;% \n  ggplot(aes(x = livingSpace, y = baseRent)) +\n  geom_point() +\n  labs(\n    x = \"living space\",\n    y = \"base rent\"\n  )\n\n\n\n\n\n\n\n\n\n\nSolution 2.2 (Exercise 2.2). To select all listings with base rent lower than \\(2500\\) EUR and living space less than \\(200\\) sqm, we can use the filter function and overwrite the old data set.\n\ndata_aux &lt;- data_aux %&gt;%\n  filter(baseRent &lt;= 2500, livingSpace &lt;= 200)\n\n\n\nSolution 2.3 (Exercise 2.3). By setting set.seed(2) we can make sure that the following results are reproducible. Similar to Section 2.3.4, we can define a split object using the initial_split function and select the training and test portion using the training and testing functions respectively.\n\nset.seed(2)\nsplit &lt;-initial_split(data_aux,0.8)\ndata_train &lt;- split %&gt;% training(split)\ndata_test &lt;- split %&gt;% testing(split)\n\n\n\nSolution 2.4 (Exercise 2.4). \n\nlm_mod &lt;- linear_reg() %&gt;%\n  fit(baseRent ~ livingSpace, data_train)\n\n\n\nSolution 2.5 (Exercise 2.5). A simple model summary can be created by passing the trained model into the tidy function.\n\nlm_mod %&gt;% tidy()\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic  p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept)     87.3    25.2        3.46 6.58e- 4\n2 livingSpace     10.4     0.322     32.2  5.49e-79\n\n\nThe estimated parameter \\(\\hat{\\beta_1} = 10.4\\) indicates that according to the linear model, we expect the base rent to rise \\(10.4\\) EUR for every additional square meter of living space.\n\n\nSolution 2.6 (Exercise 2.6). We can calculate the adjusted \\(R^2\\) and \\(MAE\\) using the metric_set function.\n\nmulti_metric&lt;- metric_set(rsq,mae)\nlm_mod %&gt;%\n  augment(data_test) %&gt;%\n  multi_metric(.pred,baseRent)\n\n# A tibble: 2 × 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 rsq     standard       0.883\n2 mae     standard     108.   \n\n\nMAE\\(=108\\) indicates that on average our estimated base rent is off by \\(108\\) EUR.\n\n\nSolution 2.8 (Exercise 2.8). \n\nset.seed(2)\nfolds &lt;- vfold_cv(data_train)\n\nlm_mod_resampling_res &lt;- linear_reg() %&gt;% \n  fit_resamples(baseRent ~ livingSpace,\n                folds,\n                metrics = multi_metric)\n\nlm_mod_resampling_res %&gt;% collect_metrics()\n\n# A tibble: 2 × 6\n  .metric .estimator    mean     n std_err .config             \n  &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;               \n1 mae     standard   116.       10  5.12   Preprocessor1_Model1\n2 rsq     standard     0.869    10  0.0153 Preprocessor1_Model1\n\n\nThe cross-validation MAE of \\(116\\) EUR compared to the test MAE of \\(108\\) EUR indicates that the cross-validation error is overestimating the true test error. This is in fact favorable, since it is preferable to have a pessimistic bias towards an estimated error. In other words, overestimating an error is always better than underestimating an error.\n\n\nSolution 2.8 (Exercise 2.8). \n\nlm_poly_mod &lt;- linear_reg() %&gt;% fit(\n  formula = baseRent ~ poly(livingSpace, 20), \n  data = data_train\n)\n\nlm_poly_mod %&gt;%\n  augment(data_test) %&gt;%\n  multi_metric(.pred,baseRent)\n\n# A tibble: 2 × 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 rsq     standard       0.349\n2 mae     standard     153.   \n\nlm_poly_mod_resampling_res &lt;- linear_reg() %&gt;% \n  fit_resamples(baseRent ~ poly(livingSpace,20),\n                folds,\n                metrics = multi_metric)\n\nlm_poly_mod_resampling_res %&gt;% collect_metrics()\n\n# A tibble: 2 × 6\n  .metric .estimator     mean     n   std_err .config             \n  &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt; &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;               \n1 mae     standard   1541.       10 1205.     Preprocessor1_Model1\n2 rsq     standard      0.624    10    0.0937 Preprocessor1_Model1\n\n\nCompared to the simple linear model, the polynomial model performs a lot worse on the test data as it severely ovefits on the training data. The CV MAE of \\(1541\\) compared to the test MAE of \\(153\\) is another redflag we should consider when evaluating model performance.\n\n\nSolution 2.9 (Exercise 2.9). We can directly pipe the training data data_train into the ggplot function to create the plot. The color argument in the geom_point function changes the color of the points and the size argument toggles the point sizes in the figure. When using geom_smooth have to express the formula in terms of x and y instead of using livingSpace and baseRent. Setting se=FALSE removes the confidence band of the estimated lines. color = \"black\", linetype=2, and linewidth=1.5 specifies the visual characteristics of the line. As with the previous plot, we can also change the axis labels using labs.\n\ndata_train %&gt;% ggplot(aes(x=livingSpace,y=baseRent))+\n  geom_point(color=\"#f07167\",\n             size = 2)+\n  geom_smooth(formula = y ~ poly(x, 20),\n              method = \"lm\",\n              color = \"black\",\n              se = FALSE,\n              linetype= 2,\n              linewidth = 1.5)+\n  geom_smooth(formula = y ~ x,\n              method = \"lm\",\n              color = \"black\",\n              se = FALSE,\n              linetype= 5,\n              linewidth = 1.5)+\n  labs(x=\"Living space in sqm\",\n       y=\"base rent in EUR\")+\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\nSolution 2.10 (Exercise 2.10). A \\(p\\)-value of \\(1e-16\\) (\\(=1\\cdot 10^{-16}\\)) indicates that we can reject the null hypotheses \\(H_0: \\beta_1 = 0\\) to the significance level \\(1-(10^{-16})\\).\n\n\nSolution 2.11 (Exercise 2.11). \n\nSince the polynomial model has more flexibility due to the additional terms, it will likely fit the training data better than the linear model, resulting in a lower training RMSE.\nThe linear model is simpler and less prone to overfitting, so it will likely produce a lower test RMSE compared to the polynomial model.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linear Models</span>"
    ]
  },
  {
    "objectID": "02_linear_models.html#session-info",
    "href": "02_linear_models.html#session-info",
    "title": "2  Linear Models",
    "section": "2.6 Session Info",
    "text": "2.6 Session Info\n\nsessionInfo()\n\nR version 4.4.0 (2024-04-24 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] ggtext_0.1.2       yardstick_1.3.1    workflowsets_1.1.0 workflows_1.1.4   \n [5] tune_1.2.1         rsample_1.2.1      recipes_1.0.10     parsnip_1.2.1     \n [9] modeldata_1.3.0    infer_1.0.7        dials_1.2.1        scales_1.3.0      \n[13] broom_1.0.5        tidymodels_1.2.0   lubridate_1.9.3    forcats_1.0.0     \n[17] stringr_1.5.1      dplyr_1.1.4        purrr_1.0.2        readr_2.1.5       \n[21] tidyr_1.3.1        tibble_3.2.1       ggplot2_3.5.1      tidyverse_2.0.0   \n\nloaded via a namespace (and not attached):\n [1] rlang_1.1.3         magrittr_2.0.3      furrr_0.3.1        \n [4] compiler_4.4.0      mgcv_1.9-1          vctrs_0.6.5        \n [7] lhs_1.1.6           pkgconfig_2.0.3     crayon_1.5.2       \n[10] fastmap_1.1.1       backports_1.4.1     labeling_0.4.3     \n[13] utf8_1.2.4          rmarkdown_2.26      prodlim_2023.08.28 \n[16] markdown_1.12       tzdb_0.4.0          bit_4.0.5          \n[19] xfun_0.43           jsonlite_1.8.8      parallel_4.4.0     \n[22] R6_2.5.1            stringi_1.8.4       parallelly_1.37.1  \n[25] rpart_4.1.23        Rcpp_1.0.12         iterators_1.0.14   \n[28] knitr_1.46          future.apply_1.11.2 Matrix_1.7-0       \n[31] splines_4.4.0       nnet_7.3-19         timechange_0.3.0   \n[34] tidyselect_1.2.1    rstudioapi_0.16.0   yaml_2.3.8         \n[37] timeDate_4032.109   codetools_0.2-20    listenv_0.9.1      \n[40] lattice_0.22-6      withr_3.0.0         evaluate_0.23      \n[43] future_1.33.2       survival_3.5-8      xml2_1.3.6         \n[46] pillar_1.9.0        foreach_1.5.2       generics_0.1.3     \n[49] vroom_1.6.5         hms_1.1.3           munsell_0.5.1      \n[52] commonmark_1.9.1    globals_0.16.3      class_7.3-22       \n[55] glue_1.7.0          tools_4.4.0         data.table_1.15.4  \n[58] modelenv_0.1.1      gower_1.0.1         grid_4.4.0         \n[61] ipred_0.9-14        colorspace_2.1-0    nlme_3.1-164       \n[64] cli_3.6.2           DiceDesign_1.10     fansi_1.0.6        \n[67] lava_1.8.0          gtable_0.3.5        GPfit_1.0-8        \n[70] digest_0.6.35       htmlwidgets_1.6.4   farver_2.1.1       \n[73] htmltools_0.5.8.1   lifecycle_1.0.4     hardhat_1.3.1      \n[76] gridtext_0.1.5      bit64_4.0.5         MASS_7.3-60.2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linear Models</span>"
    ]
  },
  {
    "objectID": "03_regularization.html",
    "href": "03_regularization.html",
    "title": "3  Regularization",
    "section": "",
    "text": "3.1 Introduction\nThis exercise session aims to review multiple linear regression (MLR) and different regularization techniques in theory and practice. Regularization techniques in linear regression involve a hyperparameter, namely the penalty. The models we consider in this session are ridge and lasso regression.\nAs for new R concepts, we will consider recipes and workflows, which are helpful for simultaneously training many different models.\nA recipe aggregates steps applied to a data set before specifying a model. Therefore, recipes include the formula, i.e., the specification for the target and features, and most of the preprocessing steps we have applied manually before.\nWorkflows serve as a container for recipes and model specifications. They streamline the training process if there are many different models involved.\nWe use the same white wine data set as in Session 02 for the introduction.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Regularization</span>"
    ]
  },
  {
    "objectID": "03_regularization.html#introduction",
    "href": "03_regularization.html#introduction",
    "title": "3  Regularization",
    "section": "",
    "text": "3.1.1 Recipes and Workflows\nWe start out by importing the data set again. For detailed description of each parameter see Cortez et al.\n\nlibrary(\"tidyverse\")\nlibrary(\"tidymodels\")\nlibrary(\"glmnet\")\n\n\n\nWarning: package 'ggtext' was built under R version 4.4.1\n\n\n\ndata_wine &lt;- read.csv(\"data/winequality-white.csv\")\ndata_wine %&gt;% glimpse()\n\nRows: 4,898\nColumns: 12\n$ fixed.acidity        &lt;dbl&gt; 7.0, 6.3, 8.1, 7.2, 7.2, 8.1, 6.2, 7.0, 6.3, 8.1,…\n$ volatile.acidity     &lt;dbl&gt; 0.27, 0.30, 0.28, 0.23, 0.23, 0.28, 0.32, 0.27, 0…\n$ citric.acid          &lt;dbl&gt; 0.36, 0.34, 0.40, 0.32, 0.32, 0.40, 0.16, 0.36, 0…\n$ residual.sugar       &lt;dbl&gt; 20.70, 1.60, 6.90, 8.50, 8.50, 6.90, 7.00, 20.70,…\n$ chlorides            &lt;dbl&gt; 0.045, 0.049, 0.050, 0.058, 0.058, 0.050, 0.045, …\n$ free.sulfur.dioxide  &lt;dbl&gt; 45, 14, 30, 47, 47, 30, 30, 45, 14, 28, 11, 17, 1…\n$ total.sulfur.dioxide &lt;dbl&gt; 170, 132, 97, 186, 186, 97, 136, 170, 132, 129, 6…\n$ density              &lt;dbl&gt; 1.0010, 0.9940, 0.9951, 0.9956, 0.9956, 0.9951, 0…\n$ pH                   &lt;dbl&gt; 3.00, 3.30, 3.26, 3.19, 3.19, 3.26, 3.18, 3.00, 3…\n$ sulphates            &lt;dbl&gt; 0.45, 0.49, 0.44, 0.40, 0.40, 0.44, 0.47, 0.45, 0…\n$ alcohol              &lt;dbl&gt; 8.8, 9.5, 10.1, 9.9, 9.9, 10.1, 9.6, 8.8, 9.5, 11…\n$ quality              &lt;int&gt; 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 7, 5, 7, 6…\n\n\nAgain, the goal is to estimate the alcohol contents (measured in alc/vol), but instead of using multiple linear regression, we use a penalized linear regression. First, we create a data split and cross-validation object:\n\nset.seed(123)\n\nsplit_wine &lt;- initial_split(data_wine)\ndata_train_wine &lt;- training(split_wine)\ndata_test_wine &lt;- testing(split_wine)\n\n\n3.1.1.1 Recipes\nInstead of directly specifying a linear model, we describe how we want to fit any model to the data and which preprocessing steps we want to add. Compared to the formula method inside the fit function, the recipe can perform more preprocessing steps via step_*() functions without executing them directly. Independent of the type of model we fit (or train, for that matter), we can reuse the following recipe:\n\nrec_wine &lt;- recipe(\n  alcohol ~.,\n  data_train_wine\n) %&gt;%\n  step_normalize(all_predictors())\n\nIn the first four lines, the recipe function specifies the formula (alcohol ~.) and template data_train_wine. The template initializes the recipe but can be changed later (e.g., when we apply these preprocessing steps to the test data). The step_normalize function in the fifth line normalizes the data passed to the recipe. Normalizing coefficients allows a comparison between features invariant of the original scale. In other words, a large absolute value of a standardized coefficient strongly influences the model.\nCalling the recipe then creates a summary of the input and operations that will be performed when training a model based on this recipe:\n\nrec_wine\n\n\n\n\n── Recipe ──────────────────────────────────────────────────────────────────────\n\n\n\n\n\n── Inputs \n\n\nNumber of variables by role\n\n\noutcome:    1\npredictor: 11\n\n\n\n\n\n── Operations \n\n\n• Centering and scaling for: all_predictors()\n\n\nWe can also use the recipe to preprocess directly. By passing the rec_wine recipe into the prep() and bake functions, the specified steps are applied to the provided data set.1\n\nrec_wine %&gt;%\n  prep() %&gt;%\n  bake(data_train_wine) %&gt;%\n  glimpse()\n\nRows: 3,673\nColumns: 12\n$ fixed.acidity        &lt;dbl&gt; 1.74676532, -0.77276698, 1.02689895, -1.13270017,…\n$ volatile.acidity     &lt;dbl&gt; -0.28262884, 0.01405471, 0.01405471, 0.40963277, …\n$ citric.acid          &lt;dbl&gt; -0.02709580, 0.96236127, 2.03427309, 0.46763273, …\n$ residual.sugar       &lt;dbl&gt; -0.75671284, 0.23276240, 1.14307962, -0.59839680,…\n$ chlorides            &lt;dbl&gt; 0.326331917, -0.035460154, 0.009763855, 3.0849964…\n$ free.sulfur.dioxide  &lt;dbl&gt; -1.35630369, 0.61777490, 1.43063080, -0.65957007,…\n$ total.sulfur.dioxide &lt;dbl&gt; -1.56230134, 1.52596077, 0.91302325, 0.04076601, …\n$ density              &lt;dbl&gt; 0.01579382, 0.57999326, 1.43797700, -0.19786750, …\n$ pH                   &lt;dbl&gt; -1.96826221, 0.46863813, -0.71688096, -0.65101879…\n$ sulphates            &lt;dbl&gt; -0.093372770, -0.267595877, -0.267595877, -0.3547…\n$ quality              &lt;dbl&gt; -0.9943613, 0.1353291, -0.9943613, 0.1353291, -0.…\n$ alcohol              &lt;dbl&gt; 9.5, 9.2, 8.9, 9.2, 10.1, 10.9, 11.0, 10.2, 13.2,…\n\n\nNote that by applying the prep and bake functions, the new data set now contains the variable quality as an ordinal feature.\n\n\n3.1.1.2 Workflows\nWorkflows combine model specifications and recipes. A workflow object can be defined using the workflow function. Adding a recipe is as simple as calling the function add_recipe and specifying the desired recipe. Calling the workflow object shows that a recipe is present, but a model is still missing.\n\nwf_wine &lt;- workflow() %&gt;%\n  add_recipe(rec_wine)\n\nwf_wine\n\n══ Workflow ════════════════════════════════════════════════════════════════════\nPreprocessor: Recipe\nModel: None\n\n── Preprocessor ────────────────────────────────────────────────────────────────\n1 Recipe Step\n\n• step_normalize()\n\n\nSpecifying an MLR model and adding it to the workflow is achieved by calling the add_model function:\n\nlm_spec&lt;- linear_reg()\n\nwf_wine &lt;- wf_wine %&gt;%\n  add_model(lm_spec)\n\nWe can then finally train the model using the fit function again:\n\nlm_fit_res &lt;- wf_wine %&gt;%\n  fit(data_train_wine)\n\nThe whole process can be visualized as follows:\n\n\n\nComponents of a workflow object\n\n\nThe circling arrows symbolize that the model specification can be swapped, meaning that we can simply specify a different model and replace it in the workflow.\n\n\n\n3.1.2 Tuning a ridge regression model\n\n3.1.2.1 Training a ridge regression model\nA ridge model can be specified with the linear_reg function.\n\nlm_ridge_spec &lt;- linear_reg(\n  penalty = 0.05,\n  mixture = 0\n  ) %&gt;%\n  set_engine(\"glmnet\")\n\nHere, the penalty argument corresponds to the hyperparameter \\(\\lambda\\) in the loss function of ridge regression:\n\\[\\begin{equation}\n\\mathcal{L}_{\\mathrm{ridge}}(\\beta,\\lambda) = \\sum_{n=1}^{N} (y_n - \\hat{y}_n)^2 + \\lambda \\sum_{i=0}^{k} \\beta_i^2\n\\end{equation}\\]\nSetting mixture = 0 indicates the model is a ridge regression, while mixture=1 corresponds to lasso regression. Any value between \\(\\alpha\\in(0,1)\\) corresponds to an elastic net with ridge proportion \\(\\alpha\\) and lasso proportion \\(1-\\alpha\\).\nUsing the set_engine(\"glmnet\") command, we specify that the ridge regression is performed using the {glmnet} package. Besides the {glmnet} library, there are around 13 other packages for fitting linear models. However, it is far from the scope of this manuscript to discuss every other library in detail.\nTo fit the ridge regression model, swap the model specification lm_spec with the model specification of the ridge regression lm_ridge_spec in the workflow using update_model and pass the output to the fit function.\n\nlm_ridge_fit_res &lt;- wf_wine %&gt;%\n  update_model(lm_ridge_spec) %&gt;%\n  fit(data_train_wine)\n\nThe estimated coefficients can then be viewed using the tidy() function:\n\nlm_ridge_fit_res %&gt;%\n  tidy()\n\n# A tibble: 12 × 3\n   term                 estimate penalty\n   &lt;chr&gt;                   &lt;dbl&gt;   &lt;dbl&gt;\n 1 (Intercept)           10.5       0.05\n 2 fixed.acidity          0.199     0.05\n 3 volatile.acidity       0.162     0.05\n 4 citric.acid            0.0532    0.05\n 5 residual.sugar         0.462     0.05\n 6 chlorides             -0.127     0.05\n 7 free.sulfur.dioxide   -0.0181    0.05\n 8 total.sulfur.dioxide  -0.0922    0.05\n 9 density               -1.15      0.05\n10 pH                     0.185     0.05\n11 sulphates              0.0613    0.05\n12 quality                0.202     0.05\n\n\nComparing the model coefficients of the penalized model with the unpenalized model yields:\n\n\n\n\n\n\n\n\n\n\n\n3.1.2.2 Determining an optimal value for \\(\\lambda\\)\nThe penalty value 0.05 was chosen arbitrarily. Depending on the penalty value, the performance of the penalized model might increase or decrease. It is, therefore, essential to find an optimal penalty value!\nHyperparameter tuning aims to streamline this approach. Instead of randomly choosing a penalty value, we can search for an optimal one by trying out a range of different penalties and choosing the optimal one within this range. Usually, one deploys an equidistant grid of candidate values. For example, if the penalty can take any value in the interval \\([0,1]\\), then try \\(\\lambda \\in \\{0,\\frac{1}{n},\\frac{2}{n},...,\\frac{n}{n}\\}\\), where \\(n \\in \\mathbb{N}\\). However, this approach comes with challenges as well. Consider the following hypothetical example where an equidistant grid with \\(n=8\\) is chosen.\n\n\n\nHypothetical example of the model performance depending on the penalty value\n\n\nThe chosen grid (blue dots) does not cover the optimal penalty value (green dot). A solution could be increasing the grid size. However, more complex models require more computing time, so testing many different grid values eventually becomes unfeasible\nIt is, therefore, important to balance grid size and compute time to obtain satisfactory results.\n\n\n3.1.2.3 Tuning for an optimal penalty value\nWhen computational resources are available, it is encouraged to perform hyperparameter tuning via cross-validation instead of a single train/validation/test split.\n\nfolds_wine &lt;- vfold_cv(data_train_wine,10)\n\nUsing the {tidymodels} framework makes hyperparameter tuning fairly uncomplicated, even when using cross-validation. By setting a hyperparameter in the model specification to tune(), we indicate that this parameter should later be tuned.\nFor the specific example of ridge regression, this can be achieved by the following code snippet:\n\nlm_ridge_spec_tune &lt;- linear_reg(\n  penalty = tune(),\n  mixture = 0\n  ) %&gt;%\n  set_engine(\"glmnet\")\n\nBy updating the workflow and subsequently training the model for different hyperparameters on each split using the tune_grid function, we obtain the results of hyperparameter tuning.\n\nlm_ridge_tune_fit_res &lt;- wf_wine %&gt;%\n  update_model(lm_ridge_spec_tune) %&gt;%\n  tune_grid(\n    resamples = folds_wine,\n    grid = 20\n  )\n\nSetting grid = 20 automatically generates \\(20\\) different candidate hyperparameters. If we want to set a grid manually, we have to specify the parameters and values to be tuned explicitly:\n\npenalty_grid &lt;- tibble(penalty = seq(0,1,length.out=100))\n\nlm_ridge_tune_fit_res &lt;- wf_wine %&gt;%\n  update_model(lm_ridge_spec_tune) %&gt;%\n  tune_grid(\n    resamples = folds_wine,\n    grid = penalty_grid,\n    metrics = metric_set(mae)\n  )\n\nIn line 8 of the snippet above, the metrics argument is passed. By setting metrics = metric_set(mae), we specify that the metric for evaluating the model is the mean absolute error.\nCalling the results of model tuning returns a nested data frame consisting of \\(10\\) rows and \\(4\\) columns. Each row contains information information like the metric about the underlying split for each tested hyperparameter.\n\nlm_ridge_tune_fit_res\n\n# Tuning results\n# 10-fold cross-validation \n# A tibble: 10 × 4\n   splits             id     .metrics           .notes          \n   &lt;list&gt;             &lt;chr&gt;  &lt;list&gt;             &lt;list&gt;          \n 1 &lt;split [3305/368]&gt; Fold01 &lt;tibble [100 × 5]&gt; &lt;tibble [0 × 3]&gt;\n 2 &lt;split [3305/368]&gt; Fold02 &lt;tibble [100 × 5]&gt; &lt;tibble [0 × 3]&gt;\n 3 &lt;split [3305/368]&gt; Fold03 &lt;tibble [100 × 5]&gt; &lt;tibble [0 × 3]&gt;\n 4 &lt;split [3306/367]&gt; Fold04 &lt;tibble [100 × 5]&gt; &lt;tibble [0 × 3]&gt;\n 5 &lt;split [3306/367]&gt; Fold05 &lt;tibble [100 × 5]&gt; &lt;tibble [0 × 3]&gt;\n 6 &lt;split [3306/367]&gt; Fold06 &lt;tibble [100 × 5]&gt; &lt;tibble [0 × 3]&gt;\n 7 &lt;split [3306/367]&gt; Fold07 &lt;tibble [100 × 5]&gt; &lt;tibble [0 × 3]&gt;\n 8 &lt;split [3306/367]&gt; Fold08 &lt;tibble [100 × 5]&gt; &lt;tibble [0 × 3]&gt;\n 9 &lt;split [3306/367]&gt; Fold09 &lt;tibble [100 × 5]&gt; &lt;tibble [0 × 3]&gt;\n10 &lt;split [3306/367]&gt; Fold10 &lt;tibble [100 × 5]&gt; &lt;tibble [0 × 3]&gt;\n\n\nBy using the autoplot function we can visualize some finding right away:\n\nlm_ridge_tune_fit_res %&gt;% autoplot()\n\n\n\n\n\n\n\n\nConsidering the figure above, the cross-validation MAE (CV-MAE) is not reduced when the model parameters are penalized. For \\(\\lambda \\in [0,0.1)\\) the CV-MAE is influenced at all. Even worse, the CV-MAE seems to increase for any \\(\\lambda \\geq 0.1\\)!\nThis is an example where penalizing model parameters is not beneficial. However, if we wish to extract the optimal hyperparameter value, we can proceed as follows:\n\n(penalty_opt &lt;- select_best(lm_ridge_tune_fit_res,\n                            metric = \"mae\")\n )\n\n# A tibble: 1 × 2\n  penalty .config               \n    &lt;dbl&gt; &lt;chr&gt;                 \n1       0 Preprocessor1_Model001\n\n\nUnsurprisingly, the optimal penalty is \\(\\lambda = 0\\).\nWe can also choose \\(\\lambda\\) according to the “one-standard error” rule:\n\n(penalty_opt_osr &lt;- select_by_one_std_err(lm_ridge_tune_fit_res,\n                            metric = \"mae\",\n                            desc(penalty))\n )\n\n# A tibble: 1 × 2\n  penalty .config               \n    &lt;dbl&gt; &lt;chr&gt;                 \n1  0.0909 Preprocessor1_Model010\n\n\nThe optimal penalty according to the “one-standard error” rule, which selects the most simple model within one standard error of the numerically optimal results, is different from \\(0\\).\n\n\n\n\n\n\nPro Tip\n\n\n\nYou can use the pull function in a similar fashion as $ to extract a single vector:\n\n(penalty_opt &lt;- penalty_opt %&gt;%\n  pull(penalty)\n)\n\n[1] 0\n\n(penalty_opt_osr &lt;- penalty_opt_osr %&gt;%\n  pull(penalty)\n)\n\n[1] 0.09090909\n\n\n\n\n\n\n3.1.2.4 Training a final model with the best hyperparameter value\nAfter determining the best hyperparameter, a final model can be trained on the whole training data and evaluated on the testing data.\nFirst, specify a final model specification with the determined hyperparameter.\n\nlm_ridge_spec_final &lt;- linear_reg(penalty = penalty_opt,\n                                  mixture = 0.0) %&gt;%\n  set_engine(\"glmnet\")\n\nUse the last_fit function to fit the final model to the entire training data. This function automatically fits the model to the training data and evaluates it on the test data with the provided metrics.\n\nlm_ridge_spec_final_fit &lt;- wf_wine %&gt;% \n  update_model(lm_ridge_spec_final) %&gt;%\n  last_fit(split_wine,\n           metrics = metric_set(mae))\n\nThe metrics can then be extracted using the collect_metrics function.\n\nlm_ridge_spec_final_fit %&gt;% \n  collect_metrics()\n\n# A tibble: 1 × 4\n  .metric .estimator .estimate .config             \n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;               \n1 mae     standard       0.418 Preprocessor1_Model1\n\n\nA visualization of the steps for effectively tuning the penalty value in a ridge regression setting can be found below.\n\n\n\nTuning procedure for the penalty in ridge regression",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Regularization</span>"
    ]
  },
  {
    "objectID": "03_regularization.html#exercises",
    "href": "03_regularization.html#exercises",
    "title": "3  Regularization",
    "section": "3.2 Exercises",
    "text": "3.2 Exercises\n\n3.2.1 Theoretical Exercises\n\nExercise 3.1 The goal of this initial exercise is to review some theoretical aspects of OLS, ridge, and lasso regression.\nIn Statistics I/II, we learned that OLS is the cornerstone of linear regression analysis. It allows us to explore and quantify the relationship between the response variable and the regressors in a relatively simple but meaningful way. We can extend the idea of a simple linear regression by adding a penalty term to the loss function we want to minimize. This process is called regularization and has been introduced in the lecture regarding ridge and lasso regression.\nConsider a simple linear model with a quantitative response variable \\(Y\\) and a single predictor \\(X\\). The simple linear model then assumes (among other things) that there is approximately a linear relationship between \\(Y\\) and \\(X\\), i.e.,\n\\[ Y \\approx \\beta_0 + \\beta_1 X. \\]\nwith unknown coefficients \\(\\beta_0,\\beta_1\\). To obtain the best estimate \\(\\beta_0\\) and \\(\\beta_1\\) for a given sample we can minimize the MSE\n\\[ \\begin{equation} \\min_{\\beta_0,\\beta_1} MSE = \\frac{1}{N}\\sum_{n=1}^{N} (y_n - (\\beta_0 + \\beta_1 x_n))^2 \\end{equation} \\]\nwhere \\(N = \\mathrm{length(Y)}\\), \\(y_1,…,y_N\\) is a realized sample of \\(Y\\), and \\(x_1,…,x_N\\) is a realized sample of \\(X\\).\nShow, that\n\\[\n\\begin{align*}\n\\hat \\beta_1 &= \\frac{\\sum_{n=1}^N (x_n - \\bar x)(y_n-\\bar y)}{\\sum_{n=1}^{N}(x_n-\\bar x)^2}\\\\\n\\hat\\beta_0 &= \\bar y - \\hat\\beta_1\\bar x.\n\\end{align*}\n\\]\nwith \\(\\bar x = \\frac{1}{N}\\sum_{n=1}^{N}x_n\\) and \\(\\bar y = \\frac{1}{N}\\sum_{n=1}^{N}y_n\\) minimizes the minimization problem above. You can assume that the critical points calculated using the partial derivatives are in fact minima and that \\(\\sum_{n=1}^{N}(x_n-\\bar x)^2\\neq 0\\).\n\n\n\nExercise 3.2 Explain the meaning of the following meme in relation to ridge regression and OLS regression:\n\n\n\nSource\n\n\n\n\nExercise 3.3 Consider the following statements and decide whether ridge or lasso regression should be applied.\n\nYou are building a predictive model for stock price prediction, and you have a large number of potential predictors. Some of these predictors might be highly correlated with each other.\nYou are modeling housing prices, and you want to prevent the model from overfitting to the training data.\nYou are working on a marketing project where you have a dataset with a mix of numerical and categorical features. You need to build a regression model to predict customer lifetime value.\n\n\n\nExercise 3.4 Come up with a scenario where a mixed model, i.e. an elastic net might be a good choice.\n\n\n\n3.2.2 Programming Exercises\nIn the following exercises, we will revisit the ImmoScout data set Apartment rental offers in Germany, but instead of considering rent prices in Augsburg, we will now consider rent prices in Munich. The data set can be downloaded using the button below.\n\nDownload MunichRental\n\nIt contains 4383 unique rental listings for flats in Munich, sourced on three dates in 2018 and 2019, and 28 different variables. We will briefly prepare the data set, create a recipe, and create a workflow before training and tuning different models.\n\nExercise 3.5 Import the data set and apply the following steps to the data:\n\nRemove the following columns from the data set\n\nc(\"serviceCharge\",\"heatingType\",\"picturecount\",\"totalRent\",\n        \"firingTypes\",\"typeOfFlat\",\"noRoomsRange\", \"petsAllowed\",\n        \"livingSpaceRange\",\"regio3\",\"heatingCosts\", \"floor\",\n        \"date\", \"pricetrend\")\n\nRemove all the NA values.\nNext, mutate the data as follows:\n\nConvert the feature interiorQual to an ordered factor variable using the following levels:\n\nc(\"simple\", \"normal\", \"sophisticated\", \"luxury\")\n\nConvert the feature condition to an ordered factor variable using the following levels:\n\nc(\"need_of_renovation\", \"negotiable\",\"well_kept\",\"refurbished\",\n         \"first_time_use_after_refurbishment\",\n         \"modernized\", \"fully_renovated\", \"mint_condition\",\n         \"first_time_use\")\n\nConvert the feature geo_plz to an unordered factor.\nConvert every logical feature into a numerical feature such that TRUE corresponds to 1 and FALSE to 0.\nRemove any flat that costs more than 4000 EUR or is bigger than 200 \\(m^2\\) from the data set.\n\n\n\n\nExercise 3.6 Use the seed 24 and create a training and test split with \\(80\\%\\) training data based on the newly mutated data set. Then, with the same seed, create a \\(5\\)-fold cross-validation data set from the training data.\n\n\nExercise 3.7 Explain the following recipe by describing each function.\n\nrec_rent &lt;- recipe(\n    formula = baseRent ~., \n    data = data_train\n  ) %&gt;%\n  update_role(scoutId, new_role = \"ID\") %&gt;%\n  step_ordinalscore(interiorQual, condition)%&gt;%\n  step_dummy(geo_plz)%&gt;%\n  step_zv(all_predictors())\n\n\n\nExercise 3.8 In the previous exercises, we initially mutated the data set (cf. Exercise 3.5) before adding mutations using the recipe function. This procedure can add unnecessary complexity or confusion since the preprocessing steps are spread across the markdown document.\nTherefore, modify the code of Exercises Exercise 3.6 and Exercise 3.7 so that the preprocessing steps of Exercise 3.5 are included in the recipe.\nHint: You can use the step_select, step_mutate, step_naomit, step_novel, and step_dummy functions for incorporating the preprocessing steps.\n\n\nExercise 3.9 Create a lasso model with penalty set to tune. Then, use the following penalty values for tuning the lasso model. Finally, create a new workflow object to add the model specification and recipe.\n\npenalty_vals &lt;- tibble(penalty = seq(0, 20, length.out = 500))\n\n\n\n\nExercise 3.10 Train the lasso model using cross-validation across all penalty values. Then, evaluate the results by finding the optimal penalty value and the optimal penalty value according to the one standard error rule with respect to the metric MAE.\n\n\nExercise 3.11 Consider the following plot, which depicts the mean out-of-sample RMSE for different penalty values. The dashed lines represent the optimal penalty and the largest penalty value, such that the mean MSE is within one standard error of the optimum.\nDecide and present an argument for which line is the optimal penalty. Furthermore, explain why we would choose the non-optimal penalty in lasso regression.\n\n\n\n\n\n\n\n\n\n\n\nExercise 3.12 Given the optimal penalty, train the Train a lasso model with the optimal penalty value on the whole training data and find out which parameters are set to \\(0\\). Then, evaluate the model on the test data by calculating the out of sample MAE and \\(R^2\\).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Regularization</span>"
    ]
  },
  {
    "objectID": "03_regularization.html#solutions",
    "href": "03_regularization.html#solutions",
    "title": "3  Regularization",
    "section": "3.3 Solutions",
    "text": "3.3 Solutions\n\nSolution 3.1 (Exercise 3.1). First, calculate the partial derivatives of\n\\[\nL(\\beta_0,\\beta_1) = \\frac{1}{N}\\sum_{n=1}^{N} (y_n - (\\beta_0 + \\beta_1 x_n))^2\n\\tag{3.1}\\]\nwith respect to \\(\\beta_1\\) and \\(\\beta_0\\).\n\\[\n\\begin{align*}\n\\frac{\\partial}{\\partial \\beta_0} L(\\beta_0,\\beta_1) &= \\frac{1}{N}\\sum_{n=1}^{N} -2(y_n-(\\beta_0 + \\beta_1x_n))\\\\\n&= -2\\bar y + 2\\beta_0 +2\\beta_1 \\bar x \\\\\n&\\overset{!}{=}0 \\\\\n\\frac{\\partial}{\\partial \\beta_1} L(\\beta_0,\\beta_1) &= \\frac{1}{N}\\sum_{n=1}^{N} -x_n(2(y_n-(\\beta_0+\\beta_1x_n))) \\\\\n&= -2\\overline{xy} + 2\\frac{1}{N}\\sum_{n=1}^{N} x_n\\beta_0+\\beta_1x_n^2\\\\\n&= -2\\overline{xy} + 2\\beta_0 \\bar x + 2\\beta_1 \\overline{x^2}\\\\\n&\\overset{!}{=}0\n\\end{align*}\n\\]\nSolving the first term for \\(\\beta_0\\) yields\n\\[\n\\beta_0 = \\bar y - \\beta_1\\bar x.\n\\]\nIn order to solve the second term for \\(\\beta_1\\) we can utilize this newly acquired representation of \\(\\beta_0\\):\n\\[\n\\begin{align*}\n-2\\overline{xy} + 2\\beta_0 \\bar x + 2\\beta_1 \\overline{x^2} = -2\\overline{xy} + 2(\\bar y - \\beta_1\\bar x) \\bar x + 2\\beta_1 \\overline{x^2} \\overset{!}{=}0.\n\\end{align*}\n\\]\nThen,\n\\[\n\\begin{align*}\n-2\\overline{xy} + 2(\\bar y - \\beta_1\\bar x) \\bar x + 2\\beta_1 \\overline{x^2}\n&= -2\\overline{xy} + 2\\bar y \\bar x- 2\\beta_1\\bar x^2+ 2\\beta_1 \\overline{x^2}\\\\\n&\\overset{!}{=} 0.\n\\end{align*}\n\\]\nThis can easily be solved for \\(\\beta_1\\), which yields\n\\[\n\\beta_1 = \\frac{\\sum_{n=1}^N (x_n - \\bar x)(y_n-\\bar y)}{\\sum_{n=1}^{N}(x_n-\\bar x)^2}.\n\\]\nNote, that\n\\[\n\\begin{align*}\n\\sum_{n=1}^N (x_n - \\bar x)(y_n-\\bar y) &= \\sum_{n=1}^N x_n y_n -\\bar xy_n-x_n\\bar y + \\bar x \\bar y\\\\\n&= N(\\overline{xy} - \\bar x\\bar y - \\bar x \\bar y + \\bar x \\bar y)\\\\\n&= N(\\overline{xy}-\\bar x\\bar y)\n\\end{align*}\n\\]\nand\n\\[\n\\begin{align*}\n\\sum_{n=1}^{N}(x_n-\\bar x)^2 &= \\sum_{n=1}^{N}x_n^2 - 2x_n\\bar x + \\bar x^2\\\\\n&= N(\\overline{x^2} - 2\\bar x ^2 + \\bar x^2)\\\\\n&= N(\\overline{x^2} - \\bar x ^2)\n\\end{align*}\n\\]\n\n\nSolution 3.2 (Exercise 3.2). The key point addresses the bias-variance trade-off.\nFrom the lecture, we know that\n\\[\n\\hat \\beta_{\\mathrm{ridge}}(\\lambda) = \\frac{\\hat\\beta_{\\mathrm{OLS}}}{1+\\lambda}\n\\]\nif the features are standardized and orthogonal.\n\nBias:\nBy growing the parameter \\(\\lambda\\), the parameter \\(\\hat\\beta_{\\mathrm{OLS}}\\) shrinks. In other words, the regularization term encourages the model to have smaller coefficient values, which means it may not fit the training data as closely as an unregularized model. This means that systematic errors are introduced to the model’s predictions.\nVariance:\nBy growing the parameter \\(\\lambda\\), we reduce variance by shrinking the coefficients’ values, which discourages them from taking very high values. This effectively constrains the model’s complexity and makes it less prone to overfitting.\n\n\n\nSolution 3.3 (Exercise 3.3). \n\nLasso regression should be used in this scenario because it can perform feature selection by driving some coefficients to zero. This is especially helpful if there are many features as it helps in dealing with correlated predictors.\nRidge regression is more suitable because it provides a smoother and more continuous shrinkage of coefficients, which reduces the risk of overfitting.\nLasso regression might be a more suitable choice as it can perform feature selection and even drive the coefficient for some categorical values to 0.\n\n\n\nSolution 3.4 (Exercise 3.4). A healthcare dataset is given to predict a patient’s readmission probability with numerous correlated features. The aim is to build a model that predicts accurately, selects the most relevant features, and mitigates multicollinearity. Here, an elastic net is the preferred choice because it combines Ridge and Lasso regression, effectively handling multicollinearity while performing feature selection, making it ideal for this complex healthcare dataset.\n\n\nSolution 3.5 (Exercise 3.5). \n\ndata_muc_filtered &lt;- data_muc %&gt;%\n  select(!c(\"serviceCharge\",\"heatingType\",\"picturecount\",\"totalRent\",\n            \"firingTypes\",\"typeOfFlat\",\"noRoomsRange\", \"petsAllowed\",\n            \"livingSpaceRange\",\"regio3\",\"heatingCosts\", \"floor\",\n            \"date\", \"pricetrend\")) %&gt;%\n  na.omit %&gt;%\n  mutate(\n    interiorQual = factor(\n      interiorQual,\n      levels = c(\"simple\", \"normal\", \"sophisticated\", \"luxury\"),\n      ordered = TRUE\n    ),\n    condition = factor(\n      condition,\n      levels = c(\"need_of_renovation\", \"negotiable\",\"well_kept\",\"refurbished\",\n                 \"first_time_use_after_refurbishment\",\n                 \"modernized\", \"fully_renovated\", \"mint_condition\",\n                 \"first_time_use\"),\n      ordered = TRUE\n    ),\n    geo_plz = factor(geo_plz)\n  ) %&gt;%\n  filter(baseRent &lt;= 4000, livingSpace &lt;= 200)\n\n\n\nSolution 3.6 (Exercise 3.6). \n\nset.seed(24)\n\nsplit &lt;- initial_split(data_muc_filtered, 0.8)\ndata_train &lt;- training(split)\ndata_test &lt;- testing(split)\n\nfolds &lt;- vfold_cv(data_train, v = 5)\n\n\n\nSolution 3.7 (Exercise 3.7). \n\nWe first set up the recipe by specifying the formula and data used in each step. Note, that by using the expression baseRent ~. we indicate that we want to fit every variable in the data_train dataset on the dependent variable baseRent.\nThe update_role function assigns the feature scoutId to a new role called ID. By doing so, the feature scoutId is no longer used as a predictor and will no longer influence our model. We will still keep it in the loop, however in case we want to access a specific listing that is only accessible using the unique scoutId.\nWe then convert the factors interiorQual and condition to ordinal scores by using the step_ordinalscore function. The translation uses a linear scale, i.e. for the feature interiorQual the level simple corresponds to the value 0 and luxury corresponds to the value 4.\nAfterward, we create dummy variables for each zip code. Here, every zip code in the data_train is treated as a new variable. Thus, we are basically replacing the feature geo_plz with 82 new features, each representing one of the 82 zip codes available in the training data.\nThe step_zv (zero variance filter) function removes all variables that contain only a single value. If, for example, a zip code does not occur in any of the entries of data_train, the whole column will be set to zero and effectively not affect our model. Thus it is in our best interest to remove those columns.\n\n\n\nSolution 3.8 (Exercise 3.8). Creating a new data split based on the unmutated data.\n\nset.seed(24)\n\nsplit &lt;- initial_split(data_muc, 0.8)\ndata_train &lt;- training(split)\ndata_test &lt;- testing(split)\n\nfolds &lt;- vfold_cv(data_train, v = 5)\n\nInserting the previous preprocessing steps into the recipe framework. Note, that this only requires changing:\n\nselect to step_select,\nna.omit to step_naomit,\nmutate to step_mutate, and\nfilter to step_filter.\n\n\nrec_rent &lt;- recipe(\n    formula = baseRent ~., \n    data = data_train\n  ) %&gt;%\n  update_role(scoutId, new_role = \"ID\") %&gt;%\n  step_select(!c(\"serviceCharge\",\"heatingType\",\"picturecount\",\"totalRent\",\n            \"firingTypes\",\"typeOfFlat\",\"noRoomsRange\", \"petsAllowed\",\n            \"livingSpaceRange\",\"regio3\",\"heatingCosts\", \"floor\",\n            \"date\", \"pricetrend\")) %&gt;%\n  step_naomit(all_predictors()) %&gt;%\n  step_mutate(\n    interiorQual = factor(\n      interiorQual,\n      levels = c(\"simple\", \"normal\", \"sophisticated\", \"luxury\"),\n      ordered = TRUE\n    ),\n    condition = factor(\n      condition,\n      levels = c(\"need_of_renovation\", \"negotiable\",\"well_kept\",\"refurbished\",\n                 \"first_time_use_after_refurbishment\",\n                 \"modernized\", \"fully_renovated\", \"mint_condition\",\n                 \"first_time_use\"),\n      ordered = TRUE\n    ),\n    geo_plz = factor(geo_plz),\n    across(where(is.logical),as.numeric)\n  ) %&gt;%\n  step_filter(baseRent &lt;= 4000, livingSpace &lt;= 200) %&gt;%\n  step_ordinalscore(interiorQual, condition)%&gt;%\n  step_novel(geo_plz)%&gt;%\n  step_dummy(geo_plz)%&gt;%\n  step_zv(all_predictors())\n\n\n\nSolution 3.9 (Exercise 3.9). \n\nmodel_lasso &lt;- linear_reg(penalty = tune(), mixture = 1.0) %&gt;%\n  set_engine(engine = \"glmnet\", path_values = penalty_vals$penalty )\n\nwf_rent &lt;- workflow() %&gt;%\n  add_recipe(rec_rent) %&gt;%\n  add_model(model_lasso)\n\n\n\nSolution 3.10 (Exercise 3.10). \n\nlasso_tune_res &lt;- \n  wf_rent %&gt;% \n  tune_grid(\n    grid = penalty_vals,\n    metrics = multi_metric,\n    resamples = folds\n  )\n\ntib &lt;- lasso_tune_res %&gt;% collect_metrics %&gt;%\n  pivot_wider(\n    names_from = .metric,\n    values_from = c(mean, std_err)\n)\n\npenalty_one_std &lt;- select_by_one_std_err(\n  lasso_tune_res,\n  metric = \"mae\",\n  desc(penalty)\n  ) %&gt;%\n  pull(penalty)\n\npenalty_opt &lt;- select_best(lasso_tune_res, metric = \"mae\") %&gt;% pull(penalty)\n\nglue::glue(\"The optimal penalty is {round(penalty_opt,2)} and \\n the optimal penalty according to the one standard error rule is {round(penalty_one_std,2)}.\")\n\nThe optimal penalty is 0 and \nthe optimal penalty according to the one standard error rule is 20.\n\n\n\n\nSolution 3.11 (Exercise 3.11). The red line depicts the optimal penalty, since it intersects the minimum of the RMSE. Especially in Lasso regression an optimal penalty parameter is often smaller than we desire. The effect of a smaller penalty parameter is, that we do not eliminate as many features as we anticipated. By increasing the penalty we can effectively overcome this problem as more features are eliminated. A disadvantage however is, that we sacrefice out-of-sample performance, as the newly chosen penalty is not optimal anymore.\n\n\nSolution 3.12 (Exercise 3.12). \n\nglm_res_best&lt;- lasso_tune_res %&gt;%\n  select_by_one_std_err(metric = \"mae\", desc(penalty))\n\nbest_penalty &lt;- glm_res_best$penalty\n\n\nlast_glm_model &lt;- linear_reg(penalty = best_penalty, mixture = 1.0) %&gt;%\n  set_engine(\"glmnet\")\n\nwf_rent_final &lt;- wf_rent %&gt;% \n  update_model(last_glm_model)\n\nlast_glm_fit &lt;- \n  wf_rent_final %&gt;% \n  last_fit(split,\n           metrics = multi_metric)\n\nlast_glm_fit %&gt;% \n  collect_metrics()\n\n# A tibble: 2 × 4\n  .metric .estimator .estimate .config             \n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;               \n1 rsq     standard       0.824 Preprocessor1_Model1\n2 mae     standard     254.    Preprocessor1_Model1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Regularization</span>"
    ]
  },
  {
    "objectID": "03_regularization.html#session-info",
    "href": "03_regularization.html#session-info",
    "title": "3  Regularization",
    "section": "3.4 Session Info",
    "text": "3.4 Session Info\n\nsessionInfo()\n\nR version 4.4.0 (2024-04-24 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] ggtext_0.1.2       glmnet_4.1-8       Matrix_1.7-0       yardstick_1.3.1   \n [5] workflowsets_1.1.0 workflows_1.1.4    tune_1.2.1         rsample_1.2.1     \n [9] recipes_1.0.10     parsnip_1.2.1      modeldata_1.3.0    infer_1.0.7       \n[13] dials_1.2.1        scales_1.3.0       broom_1.0.5        tidymodels_1.2.0  \n[17] lubridate_1.9.3    forcats_1.0.0      stringr_1.5.1      dplyr_1.1.4       \n[21] purrr_1.0.2        readr_2.1.5        tidyr_1.3.1        tibble_3.2.1      \n[25] ggplot2_3.5.1      tidyverse_2.0.0   \n\nloaded via a namespace (and not attached):\n [1] tidyselect_1.2.1    timeDate_4032.109   farver_2.1.1       \n [4] fastmap_1.1.1       digest_0.6.35       rpart_4.1.23       \n [7] timechange_0.3.0    lifecycle_1.0.4     ellipsis_0.3.2     \n[10] survival_3.5-8      magrittr_2.0.3      compiler_4.4.0     \n[13] rlang_1.1.3         tools_4.4.0         utf8_1.2.4         \n[16] yaml_2.3.8          data.table_1.15.4   knitr_1.46         \n[19] labeling_0.4.3      htmlwidgets_1.6.4   xml2_1.3.6         \n[22] DiceDesign_1.10     withr_3.0.0         nnet_7.3-19        \n[25] grid_4.4.0          fansi_1.0.6         colorspace_2.1-0   \n[28] future_1.33.2       globals_0.16.3      iterators_1.0.14   \n[31] MASS_7.3-60.2       cli_3.6.2           crayon_1.5.2       \n[34] rmarkdown_2.26      generics_0.1.3      rstudioapi_0.16.0  \n[37] future.apply_1.11.2 tzdb_0.4.0          commonmark_1.9.1   \n[40] splines_4.4.0       parallel_4.4.0      vctrs_0.6.5        \n[43] hardhat_1.3.1       jsonlite_1.8.8      hms_1.1.3          \n[46] listenv_0.9.1       foreach_1.5.2       gower_1.0.1        \n[49] glue_1.7.0          parallelly_1.37.1   codetools_0.2-20   \n[52] shape_1.4.6.1       stringi_1.8.4       gtable_0.3.5       \n[55] munsell_0.5.1       GPfit_1.0-8         pillar_1.9.0       \n[58] furrr_0.3.1         htmltools_0.5.8.1   ipred_0.9-14       \n[61] lava_1.8.0          R6_2.5.1            lhs_1.1.6          \n[64] evaluate_0.23       lattice_0.22-6      markdown_1.12      \n[67] backports_1.4.1     gridtext_0.1.5      class_7.3-22       \n[70] Rcpp_1.0.12         prodlim_2023.08.28  xfun_0.43          \n[73] pkgconfig_2.0.3",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Regularization</span>"
    ]
  },
  {
    "objectID": "03_regularization.html#footnotes",
    "href": "03_regularization.html#footnotes",
    "title": "3  Regularization",
    "section": "",
    "text": "The function names prep and bake are references to literal baking recipes: You start out by specifying the ingredients for something you want to bake. Then you prepare the ingredients before finally baking the prepped ingredients.↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Regularization</span>"
    ]
  },
  {
    "objectID": "04_regression_trees.html",
    "href": "04_regression_trees.html",
    "title": "4  Regression Trees",
    "section": "",
    "text": "4.1 Intermezzo: Imputation\nWhen working with data sets, missing values can disrupt analysis and modeling processes. In previous exercises when working with the rental listing data set, we resorted to either remove missing values completely or (in case of numerical or ordinal features) assign the worst possible value. Both of these approaches have significant drawbacks:\nTo handle these drawbacks, several imputation techniques are commonly used:\nThe approaches above require the missing data to be numerical, else we can’t really calculate a mean or median.\nConsider the following two synthetic data set examples:\nset.seed(123)\n\nn&lt;- 100\n\ndata_synth_high_corr &lt;- tibble(\n  x = seq(0,10,length.out = n),\n  z = x+rnorm(n,0,1.5),\n  y = x+rnorm(n),\n)\n\ndata_synth_low_corr &lt;- tibble(\n  x = seq(0,10,length.out = n),\n  z = exp(cos(x)),\n  y = x+rnorm(n),\n)\nBoth data sets consist of three variables \\(x,y,z\\), where both, \\(y\\) and \\(z\\) are generated using \\(x\\). In the first data set all three variables are highly correlated, whereas in the second data set only \\(x\\) and \\(y\\) are highly correlated. Depending on the complexity of the imputation technique, correlation between variables can determine how well they perform.\nConsider the case where \\(10\\%\\) of the \\(x\\)-values are removed. We can apply all four imputation techniques to impute those missing values:\nIn the figure above we can observe that the highly correlated data is estimated better using the more sophisticated imputation models compared to the simple mean and median imputation.\nWhile sophisticated imputation techniques seem to outperform simple techniques on highly correlated data, simple imputation techniques seem to be a good choice if the different features are less correlated.\nHowever, as a rule of thumb, if computational resources are available, I recommend trying different techniques and choose the one that yields best validation results.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Regression Trees</span>"
    ]
  },
  {
    "objectID": "04_regression_trees.html#intermezzo-imputation",
    "href": "04_regression_trees.html#intermezzo-imputation",
    "title": "4  Regression Trees",
    "section": "",
    "text": "By removing every NA value we potentially remove a large chunk of the underlying data which weakens the training capabilities.\nAssigning the worst possible value to each missing observation introduces a bias which can distort the true underlying distribution.\n\n\n\nMean imputation replaces missing values with the average of the observed data for a given feature, offering simplicity but also risking distortion if the data contains outliers.\nMedian imputation substitutes missing entries with the median value, making it more robust against extreme values.\nLinear imputation estimates the missing values using a linear model making it particularly robust if there are highly correlated features.\n\n\n\nk-nearest neighbors imputation identifies the k most similar records and fills missing values using their observed data. This approach can also handle ordinal or even nominal data.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Regression Trees</span>"
    ]
  },
  {
    "objectID": "04_regression_trees.html#regression-trees-in-r",
    "href": "04_regression_trees.html#regression-trees-in-r",
    "title": "4  Regression Trees",
    "section": "4.2 Regression trees in R",
    "text": "4.2 Regression trees in R\nWe use the same white wine data set as in Session 02 for the introduction.\n\n4.2.1 Data preprocessing, recipe and workflow creation\nFor detailed description of each parameter see Cortez et al.\nThe goal is to predict the alcohol contents of each wine given different attributes like density and residual sugar.\nThe following code cell contains the usual preprocessing steps required for fitting a model. For details, see tutorial on recipes and workflows.\n\nset.seed(123)\n\ndata_wine &lt;- read.csv(\"data/winequality-white.csv\")\n\nsplit_wine &lt;- initial_split(data_wine)\n\ndata_train_wine&lt;- training(split_wine)\ndata_test_wine&lt;- testing(split_wine)\n\nrec_wine &lt;- recipe(\n  alcohol ~.,\n  data = data_train_wine\n)\n\nwf_wine &lt;- workflow() %&gt;%\n  add_recipe(rec_wine)\n\n\n\n4.2.2 Fitting a basic tree\nFitting a basic tree model is as simple as fitting any other model using the tidymodels framework. The decision_tree function creates an {rpart} tree object. Since decision entail regression and classification trees, we have to specify the mode as \"regression\". Using the fit function, we can directly fit the model and evaluate it on the test set using the augment function and a preferred metric:\n\ntree_spec_basic&lt;- decision_tree(\n  mode = \"regression\"\n)\n\nwf_wine &lt;- wf_wine %&gt;% add_model(tree_spec_basic)\n\ntree_res_basic &lt;- wf_wine %&gt;%\n  fit(data_train_wine)\n\ntree_res_basic %&gt;%\n  augment(data_test_wine) %&gt;%\n  rmse(.pred,alcohol)\n\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 rmse    standard       0.632\n\n\nSince we have not passed any hyperparameters, the following rpart specific default parameters are used:\n\nmin_n = 20,\ntree_depth = round(minsplit/3), and\ncost_complexity = 0.01,\n\nTo potentially obtain better results, the parameters should be tuned. We, therefore, have to define a new model specification and set the tuneable parameters to tune().\n\ntree_spec_tune &lt;- decision_tree(\n  mode = \"regression\",\n  min_n = tune(),\n  tree_depth = tune(),\n  cost_complexity = tune()\n)\n\nIn Exercise 03, Section 3.1.2.3, we specified the candidate hyperparameters by defining a data frame with the respective hyperparameter names and candidate values, or by setting the grid attribute in the tune_grid function to a positive number indicating the number of automatically created candidate parameters.\nInstead of manually creating a data frame, we can use the extract_parameter_set_dials() function to extract all tuneable parameters and pass the output into the grid_regular() function. The grid_regular() function takes a positiv number levels \\(=n\\) as an input and returns a data frame where each column contains \\(n^{m}\\) candidate values, where \\(m\\) is the number of tunable hyperparameters.\n\ntree_grid &lt;- tree_spec_tune %&gt;%\n  extract_parameter_set_dials() %&gt;%\n  grid_regular(levels = 5)\n\nSince there are \\(m = 3\\) hyperparameters and levels is set to \\(5\\), the data frame tree_grid contains \\(125\\) combinations of candidate hyperparameters.\nAfter specifying the candidate hyperparameters, we can tune the models following the standard procedure:\n\nset.seed(123)\n\nfolds_wine &lt;-vfold_cv(data_train_wine,5)\n\nmulti_metric &lt;- metric_set(rmse,rsq)\n\nwf_wine &lt;- wf_wine %&gt;%\n  update_model(tree_spec_tune)\n\ntree_res_tune &lt;- wf_wine %&gt;%\n  tune_grid(\n    grid = tree_grid,\n    resamples = folds_wine,\n    metrics = multi_metric\n  )\n\nGiven the tuning results, we can visualize our finding with the autoplot() function.\n\ntree_res_tune %&gt;% autoplot()+\n  theme_minimal(base_size = 12)+\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\nUsing the select_best() function, we can select the best set of hyperparameters. After extracting these, passing them to the finalize_workflow() function together with the workflow object, updates the finalizes the workflow object by replacing the hyperparameters set to tune() with the selected hyperparameters. Passing the finalized workflow into the last_fit() function together with the whole data split fits the final model on the whole training data and evaluates it on the test data.\n\ntree_res_final &lt;- tree_res_tune %&gt;%\n  select_best(metric = \"rmse\") %&gt;%\n  finalize_workflow(wf_wine,.) %&gt;%\n  last_fit(split_wine) \n\ntree_res_final %&gt;%\n  collect_metrics()\n\n# A tibble: 2 × 4\n  .metric .estimator .estimate .config             \n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;               \n1 rmse    standard       0.496 Preprocessor1_Model1\n2 rsq     standard       0.837 Preprocessor1_Model1\n\n\nComparing the RMSE of the basic model (\\(0.632\\)) with the tuned model’s RMSE (\\(0.496\\)) shows that the tuning improved the performance of the tree!\n\n\n4.2.3 Visualizing results\nSince the basic tree only has a depth parameter with value \\(5\\) compared to the tuned tree with depth \\(15\\), we will consider the basic tree for a visualization. The {rpart.plot} library contains the eponymous function rpart.plot() that visualizes trees in a top-down fashion. Note: Before applying the rpart.plot() function, the fit_engine has to be extracted from the model. Strictly speaking, the object tree_res_basic contains a workflow object which in turns contains the actual model.\nEach node contains the percentage of samples at the specific level in the bottom entry and an estimate in the top entry. For example, after the first split, the left node contains \\(63\\%\\) of all samples and the estimate for the alcohol contents is \\(9.8\\) percent. The node on the right contains the remaining \\(37\\%\\) percent with an estimated alcohol content of \\(12\\) percent. The branches of the tree contain splitting conditions.\n\nlibrary(rpart.plot)\n\ntree_res_basic %&gt;%\n  extract_fit_engine() %&gt;%\n  rpart.plot(roundint=FALSE)\n\n\n\n\n\n\n\n\n\n\n4.2.4 cp-table\nThe complexity parameter (cp) table is a useful tool for asessing model performance as well. It contains the complecity parameter itself, and for each value the respective split, relative error, cross-validation error and cross-validation standard deviation.\nThe relative error for split \\(k&gt;1\\) can be calculated according to the formula\n\\[\\begin{equation}\n  \\mathrm{relative error}_k = \\mathrm{relative error}_{k-1}-\\mathrm{CP}_{k-1}\n\\end{equation}\\]\nand the relative error for \\(k=0\\) is set to \\(1\\).\nThe last entry of the column rel error contains the unexplained variance in the data, i.e. \\(1-R^2\\). We can, therefore, calculate \\(R^2 = 1-\\mathrm{rel error}_n\\), where \\(n\\) is the last row of the cp-table.\n\ntree_res_basic %&gt;%\n  extract_fit_engine() %&gt;%\n  printcp()\n\n\nRegression tree:\nrpart::rpart(formula = ..y ~ ., data = data)\n\nVariables actually used in tree construction:\n[1] chlorides      density        residual.sugar\n\nRoot node error: 5587.9/3673 = 1.5213\n\nn= 3673 \n\n        CP nsplit rel error  xerror      xstd\n1 0.524872      0   1.00000 1.00029 0.0186933\n2 0.065803      1   0.47513 0.48862 0.0114048\n3 0.063815      2   0.40932 0.41249 0.0100885\n4 0.030752      3   0.34551 0.36373 0.0091955\n5 0.024820      4   0.31476 0.33361 0.0087150\n6 0.022225      5   0.28994 0.31958 0.0081634\n7 0.010587      6   0.26771 0.29882 0.0076719\n8 0.010347      7   0.25713 0.27522 0.0074280\n9 0.010000      8   0.24678 0.27426 0.0074155",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Regression Trees</span>"
    ]
  },
  {
    "objectID": "04_regression_trees.html#exercises",
    "href": "04_regression_trees.html#exercises",
    "title": "4  Regression Trees",
    "section": "4.3 Exercises",
    "text": "4.3 Exercises\n\n4.3.1 Theoretical exercises\nIn this first exercise, we want to gain intuition for the theoretical aspects of regression trees.\nBefore diving into the process of building and evaluating a tree rigorously, we first consider different representations of binary trees, check their validity, and decide for simple datasets, whether they are suitable for regression trees.\n\nExercise 4.1 Consider the following two splits of the feature space generated by two features \\(X_1\\) and \\(X_2\\). Argue, which one of the splits was generated by a binary splitting tree!\n\n\n\n\n\n\n\nExercise 4.2 Consider the following split generated by a binary tree. \\(t_1,…,t_4\\) denote the splitting conditions, \\(R_1,…,R_4\\) the final regions, and \\(X_1,X_2\\) the variables used for evaluating the splitting conditions.\nDraw a binary tree that corresponds to the split given below.\n\n\n\n\n\n\n\nExercise 4.3 For the following scatterplots, decide whether a simple linear model ( \\(y=\\hat \\beta_1x+\\hat \\beta_0\\) ) or a regression tree should be chosen for modeling the data.\n\n\n\n\n\n\n\n\n\n\n\nExercise 4.4 Now, that we have considered some visual examples of trees and gained an intuition of situations where trees might be a suitable model, we now want to focus on the process of building a tree.\nConsider the following dataset. Calculate the first optimal splitting point with respect to \\(x\\).\n\ndata &lt;- tibble(\n  x = c(1,0.5,2.0,5.5,4.5),\n  y = c(10,7,8,3,4)\n)\ndata\n\n# A tibble: 5 × 2\n      x     y\n  &lt;dbl&gt; &lt;dbl&gt;\n1   1      10\n2   0.5     7\n3   2       8\n4   5.5     3\n5   4.5     4\n\n\nIn order to do so, you have to proceed as follows:\n\nDerive the order statistics of \\(\\{x_1,...,x_n\\}\\)\nDerive the set \\(S := \\left\\{\\frac{1}{2}(x_{(r)}+x_{(r+1)}):r=1,...,n-1\\right\\}\\) of all potential splitting points.\nFor each potential splitting point, derive the regions \\(R_1\\) and \\(R_2\\) and calculate the estimate \\(\\hat y_1\\) and \\(\\hat y_2\\) for the respective regions.\nCalculate the loss \\(\\mathcal{L}(y,\\hat y) := \\sum_{i:x_i\\in R_1} (y_i-\\hat y)^2 + \\sum_{i:x_i\\in R_2}(y_i-\\hat y)^2\\).\nDerive the optimal splitting point by settling for the splitting point leading to the smallest loss \\(\\mathcal{L}\\).\n\n\n\nExercise 4.5 Given the tibble data, create a simple scatter plot and add a dashed line indicating the initial splitting point. An example of what such a plot could look like can be found below.\n\n\n\n\n\n\n\n\n\n\n\nExercise 4.6 Calculate the improvement of the given split. Recall, that the improvement of a split is given by\n\\[\n\\frac{\\mathrm{MSE}_1 \\cdot n_1 - (\\mathrm{MSE}_2 \\cdot n_2 +  \\mathrm{MSE}_3 \\cdot n_3)}{\\mathrm{MSE_1}\\cdot n_1},\n\\]\nwhere \\(\\mathrm{MSE}_1\\) denotes the mean squared error of the region before the split and \\(\\mathrm{MSE_2}\\) and \\(\\mathrm{MSE_3}\\) are the mean square errors of the respective regions after the split. \\(n_i,\\, i=1,2,3\\) denotes the number of samples in the respective region.\n\n\n\n4.3.2 Programming Exercises\nIn this exercise, we want to apply our theoretical knowledge to training a tree-based model on the Apartment rental offers in Germany dataset. As in Session 03 we will be using the rental offers in Munich to build a predictive model for the base rent.\n\nExercise 4.7 Import the data set, create a training/testing split and a \\(5\\)-fold CV object on the training data using set.seed(2).\n\n\nExercise 4.8 Explain the syntax and semantics of the following code snippet.\n\ndata_muc %&gt;%\n  select_if(where(~sum(is.na(.))&gt;0)) %&gt;%\n  is.na() %&gt;%\n  colSums() %&gt;%\n  tibble( names = names(.),\n          n = .) %&gt;%\n  arrange(desc(n))\n\n# A tibble: 12 × 2\n   names               n\n   &lt;chr&gt;           &lt;dbl&gt;\n 1 heatingCosts     3565\n 2 petsAllowed      2013\n 3 interiorQual     1584\n 4 firingTypes      1243\n 5 condition        1206\n 6 heatingType      1108\n 7 typeOfFlat        847\n 8 yearConstructed   751\n 9 floor             631\n10 totalRent         440\n11 serviceCharge     150\n12 pricetrend         22\n\n\n\n\nExercise 4.9 Create a recipe based on the following description:\n\nCreate a recipe for a regression model with baseRent as the target variable and all other columns as predictors.\nUpdate the role of the scoutId column to “ID”.\nRemove the following specified columns from the dataset:\n\nc(\"serviceCharge\",\"heatingType\",\"picturecount\",\"totalRent\",\n      \"firingTypes\",\"typeOfFlat\",\"noRoomsRange\", \"petsAllowed\",\n      \"livingSpaceRange\",\"regio3\",\"heatingCosts\", \"floor\",\n      \"date\", \"pricetrend\")\n\n [1] \"serviceCharge\"    \"heatingType\"      \"picturecount\"     \"totalRent\"       \n [5] \"firingTypes\"      \"typeOfFlat\"       \"noRoomsRange\"     \"petsAllowed\"     \n [9] \"livingSpaceRange\" \"regio3\"           \"heatingCosts\"     \"floor\"           \n[13] \"date\"             \"pricetrend\"      \n\n\nConvert interiorQual and condition into ordered factors with specified levels and geo_plz into an unordered factor.\nCreate a specification that assigns a previously unseen factor level to new using the step_novel() function.\nConvert geo_plz into dummy variables.\nCreate ordinal scores for every ordered predictor.\nImpute missing values for all ordered predictors using k-nearest neighbors.\nFilter rows in the dataset to retain only observations where baseRent is at most \\(4000\\) EUR and livingSpace is at most \\(200\\) sqm.\n\n\n\nExercise 4.10 Create an instance of the decision_tree class where the parameters min_n,tree_depth, and cost_complexity are set to tune.\n\n\nExercise 4.11 Create a workflow and add the previously specified model and recipe.\n\n\nExercise 4.12 Instead of specifying the grid manually, use the extract_parameter_set_dials function to create a regular grid with \\(4\\) levels.\n\n\n\nExercise 4.13 Tune the model on the cross-validation set created in Exercise 4.7. As for the Use the following metric set for evaluating the tuning results.\n\nmulti_metric &lt;- metric_set(rmse,rsq)\n\n\n\nExercise 4.14 Given the following plot. What can you say about the relationship between the tree parameters Tree Depth, Minimal Node Size, and Cost-Complexity Parameter with respect to the RMSE?\n\n\n\n\n\n\n\nExercise 4.15 Select the best model with respect to the metric MAE and fit a final model using these parameters. Then, fit the best model on the whole training data and evaluate it on the test data using the previously defined metrics set.\n\n\nExercise 4.16 It is usually easier to get a feeling for model performance by visualizing the results. One way to do that would be to plot the predicted values of our model against the true values. By adding a simple line through the origin with slope one, we can then evaluate the estimates as follows:\nPoints that are closely scattered around this line are well predicted, whereas points further away from this line indicate that the model performed badly.\nThe goal of this exercise is for you to rebuild the plot that is depicted below.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Regression Trees</span>"
    ]
  },
  {
    "objectID": "04_regression_trees.html#solutions",
    "href": "04_regression_trees.html#solutions",
    "title": "4  Regression Trees",
    "section": "4.4 Solutions",
    "text": "4.4 Solutions\n\nSolution 4.1 (Exercise 4.1). Split 1 can’t be produced by a binary tree, because the bottom-center rectangle is overlapping the left-most rectangle.\n\n\nSolution 4.2 (Exercise 4.2). \n\n\nSolution 4.3 (Exercise 4.3). \n\nFor the data in the first plot, we should use a simple linear model, as the data seems to follow a simple linear trend.\nA linear model is most likely not suitable for modelling this data, as the shape of the cloud of points looks more like a parabola instead of a line.\nAs the third plot consists of points that can be assigned to four (almost) distinct regions, a regression tree seems to be more suitable than a linear model.\nAt first, the data in the fourth plot seems to be too messy to make a decision. However, upon closer inspection, there are several indicators that a linear model might perform better:\n\nThe points in the center seem to follow a positive linear trend.\nThe deviations of points around this linear trend seem to be distributed in a way, that there are more points towards the line than further away. So the residuals could be assumed to be normally distributed.\n\n\n\n\nSolution 4.4 (Exercise 4.4). \n\nloss_x&lt;- function(data,r) {\n  xr = sort(data$x)[r]\n  y1 &lt;- mean(data$y[data$x&lt;=xr])\n  y2 &lt;- mean(data$y[data$x&gt;xr])\n\n  loss&lt;-sum((data$y[data$x&lt;=xr]-y1)^2) + sum((data$y[data$x&gt;xr]-y2)^2)\n  \n  return(loss)\n}\n\nSince we are interested in finding the optimal split with respect to \\(x_1=x\\), consider the sets of all possible splits \\[\\begin{equation*}\n  S := \\left\\{\\frac{1}{2}(x_{(r)}+x_{(r+1)}):r=1,...,n-1\\right\\} = \\{0.75,1.5,3.25,5\\}.\n\\end{equation*}\\]\nHere, \\(\\{x_{(r)},\\, r = 1,...,n\\} = \\{0.5,1,2,4.5,5.5\\}\\) denotes the order statistic of \\(x\\).\nFor \\(r=1\\) we have \\(s = 0.75\\) and \\[\\begin{align*}\nR_1(1,0.75) &= \\{x: x \\leq 0.75\\} = \\{0.5\\},\\\\\nR_2(1,0.75) &= \\{x: x &gt; 0.75\\} = \\{1.0,2.5,5.5,4.5\\}.\n\\end{align*}\\]\nThen,\n\\[\\begin{align*}\n\\hat y_1 &= \\frac{1}{|R_1|}\\sum_{i:x_{i}\\in R_1} y_i = \\frac{1}{1}\\cdot 7 = 7,\\\\\n\\hat y_2 &= \\frac{1}{|R_2|}\\sum_{i:x_{i}\\in R_2} y_i = \\frac{1}{4}(10+8+3+4) = 6.25.\n\\end{align*}\\]\nGiven the above, we can calculate the Loss with respect to \\(s = 0.75\\), which is given by\n\\[\\begin{align*}\n\\mathcal{L}(y,\\hat y) &= \\sum_{i:x_{i}\\in R_1} (y_i-\\hat y_{R_1})^2 + \\sum_{i:x_{i}\\in R_2} (y_i-\\hat y_{R_2})^2 \\\\\n&= (7 -7)^2 + (10-6.25)^2 + (8-6.25)^2 + (3-6.25)^2 + (4-6.25)^2\\\\\n&= 32.75\n\\end{align*}\\]\n\nloss_x(data,1)\n\n[1] 32.75\n\n\nFor \\(r=2\\) we have \\(s = 1.5\\) and \\[\\begin{align*}\nR_1(1,1.5) &= \\{x: x \\leq 1.5\\} = \\{0.5,1.0\\},\\\\\nR_2(1,1.5) &= \\{x: x &gt; 1.5\\} = \\{2.5,5.5,4.5\\}.\n\\end{align*}\\] Then, \\[\\begin{align*}\n\\hat y_1 &= \\frac{1}{|R_1|}\\sum_{i:x_{i}\\in R_1} y_i = \\frac{1}{2}\\cdot (7+10) = 8.5,\\\\\n\\hat y_2 &= \\frac{1}{|R_2|}\\sum_{i:x_{i}\\in R_2} y_i = \\frac{1}{3}(8+3+4) = 5.\n\\end{align*}\\] Given the above, we can calculate the Loss with respect to \\(s = 1.5\\), which is given by\n\\[\\begin{align*}\n\\mathcal{L}(y,\\hat y) &= \\sum_{i:x_{i}\\in R_1} (y_i-\\hat y_{R_1})^2 + \\sum_{i:x_{i}\\in R_2} (y_i-\\hat y_{R_2})^2 \\\\\n&= (7-8.5)^2 + (10-8.5)^2  + (8-5)^2 + (3-5)^2 + (4-5)^2\\\\\n&= 18.5\n\\end{align*}\\]\n\nloss_x(data,2)\n\n[1] 18.5\n\n\nFor \\(r=3\\) we have \\(s = 3.25\\) and \\[\\begin{align*}\nR_1(1,3.25) &= \\{x: x \\leq 3.25\\} = \\{0.5,1.0, 2.5 \\},\\\\\nR_2(1,3.25) &= \\{x: x &gt; 3.25\\} = \\{5.5,4.5\\}.\n\\end{align*}\\] Then, \\[\\begin{align*}\n\\hat y_1 &= \\frac{1}{|R_1|}\\sum_{i:x_{i}\\in R_1} y_i = \\frac{1}{3}\\cdot (7+10+8) = 8.333,\\\\\n\\hat y_2 &= \\frac{1}{|R_2|}\\sum_{i:x_{i}\\in R_2} y_i = \\frac{1}{2}(3+4) = 3.5.\n\\end{align*}\\] Given the above, we can calculate the Loss with respect to \\(s = 4\\), which is given by\n\\[\\begin{align*}\n\\mathcal{L}(y,\\hat y) &= \\sum_{i:x_{i}\\in R_1} (y_i-\\hat y_{R_1})^2 + \\sum_{i:x_{i}\\in R_2} (y_i-\\hat y_{R_2})^2 \\\\\n&= (7-8.333)^2 + (10-8.333)^2  + (8-8.333)^2 + (3-3.5)^2 + (4-3.5)^2\\\\\n&= 5.167\n\\end{align*}\\]\n\nloss_x(data,3)\n\n[1] 5.166667\n\n\nFor \\(r=4\\) we have \\(s = 5\\) and \\[\\begin{align*}\nR_1(1,5) &= \\{x: x \\leq 5\\} = \\{0.5,1.0, 2.5,4.5 \\},\\\\\nR_2(1,5) &= \\{x: x &gt; 5\\} = \\{5.5\\}.\n\\end{align*}\\] Then, \\[\\begin{align*}\n\\hat y_1 &= \\frac{1}{|R_1|}\\sum_{i:x_{i}\\in R_1} y_i = \\frac{1}{4}\\cdot (7+10+8+4) = 7.25,\\\\\n\\hat y_2 &= \\frac{1}{|R_2|}\\sum_{i:x_{i}\\in R_2} y_i = \\frac{1}{1}\\cdot 3 = 3.\n\\end{align*}\\] Given the above, we can calculate the Loss with respect to \\(s = 5\\), which is given by\n\\[\\begin{align*}\n\\mathcal{L}(y,\\hat y) &= \\sum_{i:x_{i}\\in R_1} (y_i-\\hat y_{R_1})^2 + \\sum_{i:x_{i}\\in R_2} (y_i-\\hat y_{R_2})^2 \\\\\n&= (7-7.25)^2 + (10-7.25)^2  + (8-7.25)^2 + (4-7.25)^2 + (3-3)^2\\\\\n&= 18.75\n\\end{align*}\\]\n\nloss_x(data,4)\n\n[1] 18.75\n\n\nSince \\(\\mathcal{L}(y,\\hat y)\\) is the lowest for \\(r=3\\), i.e., \\(\\mathcal{L}(y,\\hat y) = 5.167\\), \\(s = 3.25\\) is the optimal splitting point with respect to \\(x\\).\n\n\nSolution 4.5 (Exercise 4.5). \n\ntitle_text = \"Scatterplot showing the &lt;span style='color:red'&gt;optimal threshold&lt;/span&gt; for an initial split with respect to x\"\n\ndata %&gt;% ggplot(aes(x,y))+\n  geom_point(size = 3, alpha = 0.7) +\n  geom_vline(xintercept = 3.25, linetype = \"dashed\", color = \"red\") +\n  theme_minimal()+\n  theme(\n    plot.title = element_markdown()\n  )+\n  labs( x = \"x\",\n        title = title_text)\n\n\n\n\n\n\n\n\n\n\nSolution 4.6 (Exercise 4.6). The improvement is given by the following term.\n\\[\\begin{equation*}\n\\frac{\\mathrm{MSE}_1 \\cdot n_1 - (\\mathrm{MSE}_2 \\cdot n_2 +  \\mathrm{MSE}_3 \\cdot n_3)}{\\mathrm{MSE_1}\\cdot n_1}\n\\end{equation*}\\]\nCalculating \\(MSE_i\\) for \\(i=1,2,3\\) yields\n\\[\\begin{align*}\nn_1 \\cdot \\mathrm{MSE}_1 &= (10-6.4)^2 + (7-6.4)^2 + (8-6.4)^2 + (3-6.4)^2 + (4-6.4)^2 = 33.2, \\\\\nn_2 \\cdot \\mathrm{MSE}_2 &= (7-8.333)^2 + (10-8.333)^2  + (8-8.333)^2 = 4.667, \\\\\nn_3 \\cdot \\mathrm{MSE}_3 &= (3-3.5)^2 + (4-3.5)^2 = 0.5\\ .\n\\end{align*}\\]\nThe improvement for this split is therefore\n\\[\\begin{equation*}\n  \\frac{\\mathrm{MSE}_1 \\cdot n_1 - (\\mathrm{MSE}_2 \\cdot n_2 +  \\mathrm{MSE}_3 \\cdot n_3)}{\\mathrm{MSE_1}\\cdot n_1} = \\frac{33.2 - (4.667 + 0.5)}{33.2} = 0.8444\n\\end{equation*}\\]\n\n\nSolution 4.7 (Exercise 4.7). \n\ndata_muc &lt;- read.csv(\"data/rent_muc.csv\")\n\n\nset.seed(24)\nsplit_rent &lt;- initial_split(data_muc)\ndata_train &lt;- training(split_rent)\ndata_test &lt;- testing(split_rent)\nfolds &lt;- vfold_cv(data_train, v = 5)\n\n\n\nSolution 4.8 (Exercise 4.8). \n\ndata_muc %&gt;%\n  select_if(where(~sum(is.na(.))&gt;0)) %&gt;%\n  is.na() %&gt;%\n  colSums() %&gt;%\n  tibble( names = names(.),\n          n = .) %&gt;%\n  arrange(desc(n))\n\n\nThe %&gt;% operator passes the data set data_muc to the next function.\nselect_if selects columns in a data frame based on the condition that where(~ sum(is.na(.)) &gt; 0) which checks if the sum of NA values in a column is greater than 0.\nThe is.na() function checks whether an entry in the data set is NA or not and returns True or FALSE respectively. Therefore, by applying the is.na() function, a data set containing only boolean values is returned.\nThe colSums function adds up all values in each column, where TRUE = 1 and FALSE = 0, returning a named vector containing the sum of all TRUE values and the respective variable names.\nThen, the data set is transformed using the tibble() function such that the returned tibble only consists of two columns containing the variable name and column sum.\nIn the last step, the data set is ordered with respect to the number of missing values in descending order using the arrange() and desc() function.\n\n\n\nSolution 4.9 (Exercise 5.6). \n\nrec_rent &lt;- recipe(\n    formula = baseRent ~., \n    data = data_train\n  ) %&gt;%\n  update_role(scoutId, new_role = \"ID\") %&gt;%\n  step_select(!c(\"serviceCharge\",\"heatingType\",\"picturecount\",\"totalRent\",\n            \"firingTypes\",\"typeOfFlat\",\"noRoomsRange\", \"petsAllowed\",\n            \"livingSpaceRange\",\"regio3\",\"heatingCosts\", \"floor\",\n            \"date\", \"pricetrend\")) %&gt;%\n  step_mutate(\n    interiorQual = factor(\n      interiorQual,\n      levels = c(\"simple\", \"normal\", \"sophisticated\", \"luxury\"),\n      ordered = TRUE\n    ),\n    condition = factor(\n      condition,\n      levels = c(\"need_of_renovation\", \"negotiable\",\"well_kept\",\n                 \"refurbished\",\"first_time_use_after_refurbishment\",\n                 \"modernized\",\"fully_renovated\", \"mint_condition\",\n                 \"first_time_use\"),\n      ordered = TRUE\n    ),\n    geo_plz = factor(geo_plz)\n  )%&gt;%\n  step_novel(geo_plz)%&gt;%\n  step_dummy(geo_plz)%&gt;%\n  step_ordinalscore(all_ordered_predictors())%&gt;%\n  step_impute_knn(all_predictors()) %&gt;%\n  step_filter(baseRent &lt;= 4000, livingSpace &lt;= 200)\n\n\n\nSolution 4.10 (Exercise 4.10). \n\nmodel_rt_tune &lt;-  \n  decision_tree(\n    min_n = tune(),\n    tree_depth = tune(),\n    cost_complexity = tune()\n    ) %&gt;% \n  set_mode(\"regression\") %&gt;% \n  set_engine(\"rpart\")\n\n\n\nSolution 4.11 (Exercise 4.11). \n\nwf_rent &lt;- \n  workflow() %&gt;%\n  add_recipe(rec_rent) %&gt;%\n  add_model(model_rt_tune)\n\n\n\nSolution 4.12 (Exercise 4.12). \n\ntree_grid &lt;- wf_rent %&gt;% \n  extract_parameter_set_dials %&gt;% \n  grid_regular(levels = 4)\n\n\n\nSolution 4.13 (Exercise 4.13). \n\nmulti_metric &lt;- metric_set(rmse,rsq,mae)\n\n\nrt_res &lt;- \n  wf_rent %&gt;% \n  tune_grid(\n    grid = tree_grid,\n    metrics = multi_metric,\n    resamples = folds\n  )\n\nTo speed things up, the following tibble already contains the optimal parameters according to the tuning procedure:\n\nrt_res_tune_best &lt;- tibble(\n  min_n = 14,\n  tree_depth = 10,\n  cost_complexity = 0.0001\n)\n\n\n\nSolution 4.14 (Exercise 4.14). \n\nautoplot(rt_res) + theme_minimal()\n\n\n\n\n\n\n\nTree Depth:\n\nIncreasing tree depth (lines for depths 1, 5, 10, 15) generally reduces the RMSE across all plots, indicating better model performance as depth grows.\nHowever, for deeper trees, RMSE increases when the Cost-Complexity Parameter is high, due to over-regularization.\n\nMinimal Node Size:\n\nSmaller minimal node sizes (e.g., 2) allow the tree to split more finely, resulting in lower RMSE when the Cost-Complexity Parameter is low.\nLarger minimal node sizes (e.g., 40) limit splitting, which leads to higher RMSE across all complexity values.\n\nCost-Complexity Parameter:\n\nA small Cost-Complexity Parameter (e.g., (10^{-8})) corresponds to minimal pruning, leading to low RMSE (better performance).\nAs the Cost-Complexity Parameter increases, the tree gets pruned more aggressively, and RMSE rises, especially for shallow trees or larger node sizes.\n\n\n\n\nSolution 4.15 (Exercise 4.15). \n\nrt_res_best&lt;- rt_res %&gt;%\n  select_best(metric = \"mae\")\n\nlast_rt_fit &lt;- wf_rent %&gt;%\n  finalize_workflow(rt_res_best) %&gt;%\n  last_fit(split_rent)\n\nlast_rt_fit %&gt;% collect_metrics()\n\nUsing the parameters from the pre-specified tibble to avoid tuning time:\n\nlast_rt_fit &lt;- wf_rent %&gt;%\n  finalize_workflow(rt_res_tune_best) %&gt;%\n  last_fit(split_rent)\n\nlast_rt_fit %&gt;% collect_metrics()\n\n# A tibble: 2 × 4\n  .metric .estimator .estimate .config             \n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;               \n1 rmse    standard     622.    Preprocessor1_Model1\n2 rsq     standard       0.616 Preprocessor1_Model1\n\n\n\n\nSolution 4.16 (Exercise 4.16). \n\ntitle_text &lt;- \"Predictions of the test set plotted against the actual values\"\nlast_rt_fit %&gt;%\n  collect_predictions() %&gt;%\n  ggplot(aes(baseRent, .pred)) +\n  geom_abline(slope = 1, lty = 2, color = \"red\", alpha = 1) +\n  geom_point(alpha = 0.6, color = \"green\")+\n  labs(\n    x = \"True base rent\",\n    y = \"Estimated base rent\",\n    title = title_text\n  )+\n  coord_fixed()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Regression Trees</span>"
    ]
  },
  {
    "objectID": "04_regression_trees.html#session-info",
    "href": "04_regression_trees.html#session-info",
    "title": "4  Regression Trees",
    "section": "4.5 Session Info",
    "text": "4.5 Session Info\n\nsessionInfo()\n\nR version 4.4.0 (2024-04-24 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] rpart.plot_3.1.2   rpart_4.1.23       patchwork_1.2.0    ggtext_0.1.2      \n [5] yardstick_1.3.1    workflowsets_1.1.0 workflows_1.1.4    tune_1.2.1        \n [9] rsample_1.2.1      recipes_1.0.10     parsnip_1.2.1      modeldata_1.3.0   \n[13] infer_1.0.7        dials_1.2.1        scales_1.3.0       broom_1.0.5       \n[17] tidymodels_1.2.0   lubridate_1.9.3    forcats_1.0.0      stringr_1.5.1     \n[21] dplyr_1.1.4        purrr_1.0.2        readr_2.1.5        tidyr_1.3.1       \n[25] tibble_3.2.1       ggplot2_3.5.1      tidyverse_2.0.0   \n\nloaded via a namespace (and not attached):\n [1] tidyselect_1.2.1    timeDate_4032.109   farver_2.1.1       \n [4] fastmap_1.1.1       digest_0.6.35       timechange_0.3.0   \n [7] lifecycle_1.0.4     ellipsis_0.3.2      survival_3.5-8     \n[10] magrittr_2.0.3      compiler_4.4.0      rlang_1.1.3        \n[13] tools_4.4.0         utf8_1.2.4          yaml_2.3.8         \n[16] data.table_1.15.4   knitr_1.46          labeling_0.4.3     \n[19] htmlwidgets_1.6.4   xml2_1.3.6          DiceDesign_1.10    \n[22] withr_3.0.0         nnet_7.3-19         grid_4.4.0         \n[25] fansi_1.0.6         colorspace_2.1-0    future_1.33.2      \n[28] globals_0.16.3      iterators_1.0.14    MASS_7.3-60.2      \n[31] cli_3.6.2           rmarkdown_2.26      generics_0.1.3     \n[34] rstudioapi_0.16.0   future.apply_1.11.2 tzdb_0.4.0         \n[37] commonmark_1.9.1    splines_4.4.0       parallel_4.4.0     \n[40] vctrs_0.6.5         hardhat_1.3.1       Matrix_1.7-0       \n[43] jsonlite_1.8.8      hms_1.1.3           listenv_0.9.1      \n[46] foreach_1.5.2       gower_1.0.1         glue_1.7.0         \n[49] parallelly_1.37.1   codetools_0.2-20    stringi_1.8.4      \n[52] gtable_0.3.5        munsell_0.5.1       GPfit_1.0-8        \n[55] pillar_1.9.0        furrr_0.3.1         htmltools_0.5.8.1  \n[58] ipred_0.9-14        lava_1.8.0          R6_2.5.1           \n[61] lhs_1.1.6           evaluate_0.23       lattice_0.22-6     \n[64] markdown_1.12       backports_1.4.1     gridtext_0.1.5     \n[67] class_7.3-22        Rcpp_1.0.12         prodlim_2023.08.28 \n[70] xfun_0.43           pkgconfig_2.0.3",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Regression Trees</span>"
    ]
  },
  {
    "objectID": "05_bagging_rf.html",
    "href": "05_bagging_rf.html",
    "title": "5  Random Forests",
    "section": "",
    "text": "5.1 Introduction\nIn this exercise session we will briefly talk about some theoretical considerations when applying bootstrap sampling, bagging and training a random forest before performing a more in-depth case study of binary classification. The case-study assumes that you are familiar with penalized logistic regressions (similar to lasso regression, see Session 03 ) and classification trees (similar to regression trees introduced in Session 4). We will however, revisit different evaluation metrics for a binary classifier before training any of the models which should help you to develop a feeling for model performance.\nNote, that some of the models we train might take a few (up to many) minutes depending on your hardware. One way to circumvent long training processes is to use a simple training/validation/test split instead of CV.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Random Forests</span>"
    ]
  },
  {
    "objectID": "05_bagging_rf.html#introduction",
    "href": "05_bagging_rf.html#introduction",
    "title": "5  Random Forests",
    "section": "",
    "text": "5.1.1 Evaluation of binary classifiers\nBefore we start with the actual exercise, let us quickly review some important metrics and concepts for evaluating binary classifiers.\n\n5.1.1.1 Confusion Matrix\n\n\n\nConfusion Matrix, Source: Wikipedia\n\n\n\n\n5.1.1.2 ROC Curve and Precision-Recall Curve\nWhen passing a sample into the classification model, the return-value is usually a probability \\(p\\in[0,1]\\) that denotes the probability of the sample belonging to the Positives (in this hypothetical setting we assume that there are two classes “Positives” and “Negatives”). Intuitively it makes sense to say, that a given sample \\(x\\) belongs to the Positives if \\(p\\geq q = 0.5\\). However, this threshold \\(q = 0.5\\) can be adjusted. Depending on this threshold \\(q\\) , the values in our confusion matrix change.\nExample:\nSet \\(q = 0\\), then \\(p\\) is always larger or equal to \\(q\\), which means that we assign every value to the positives. Then, our True Positive Rate (\\(\\mathrm{TPR} = \\frac{\\mathrm{TP}}{\\mathrm{P}}\\)) will be equal to \\(1\\) since all samples are assigned to the Positives. However, the True Negative Rate (\\(\\mathrm{TNR} = \\frac{\\mathrm{TN}}{\\mathrm{N}}\\)) will be equal to 0, since not one sample has been assigned to the Negatives, meaning that \\(\\mathrm{TN} = 0\\) .\nA way to visualize the change in our confusion matrix depending on the threshold \\(q\\) is given by the so-called ROC (Receiver-Operator Curve) curve and Precision-Recall Curve.\nROC Curve:\nThe ROC curve shows the \\(\\mathrm{TPR}\\) (also known as recall or sensitivity) plotted against the \\(\\mathrm{TNR}\\) (also known as 1-specificity). By plotting these two values against each other, we can identify a good model by checking whether the curve generated by all the thresholds is approaching the left top corner of a plot, indicating that both \\(\\mathrm{TPR}\\) and \\(\\mathrm{TNR}\\) are equal to 1, i.e. the model perfectly classifies all True Positives and all True Negatives. An exemplary plot can be found below.\n\n\n\nROC Curve, Source: developers.google.com\n\n\nPR Curve:\nThe Precision-Recall Curve on the other hand shows the Precision (\\(\\mathrm{Precision} = \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}}\\) ) plotted against the Recall (\\(\\mathrm{Recall} = \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}}\\)). Precision basically measures the proportion of correctly identified Positives, while Recall measures the proportion of correctly identified actual Positives. If the line generated by a model is close to the top right corner, the model is relevant, has a high precision, and sensitivity.\nAn exemplary plot can be found below.\n\n\n\nPR Curve, Source: I made it myself :’)\n\n\nWhat does a high precision and recall actually mean (I find the definition above kind of hard to grasp)? Let us consider a simple example:\nExample:\nImagine you are developing a classification model for detecting a rare disease (Positves corresponds to detecting the decease). There are 10000 people in the observed data and only 10 of them are infected with said disease. One way to set up a model (regardless of the features) can be to simply label everyone as not having the disease which would effectively result in an accuracy of 99.9%, Hurray . However, this model is obviously not the best since we failed to identify any of the sick people correctly. So, after tweaking the model we now have a model that might be less accurate but identifies sick patients better. What does better in this context mean? By looking at the definition of Precision and Recall above, you may notice that they only differ by the second summand in the denominator of the fraction, namely False Positives and False Negatives. Before we continue, think for yourself, which of those are worse in the scenario of detecting a disease? The right answer would be False Negatives, since we fail to identify a sick patient! That is why a sensitive model is crucial here as well\nIn summary: especially for imbalanced data sets, we do not only want to achieve a high accuracy since that is fairly easy to achieve. We Also want a high precision or recall, focusing on one or the other depending on the model objective.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Random Forests</span>"
    ]
  },
  {
    "objectID": "05_bagging_rf.html#random-forests",
    "href": "05_bagging_rf.html#random-forests",
    "title": "5  Random Forests",
    "section": "5.2 Random forests",
    "text": "5.2 Random forests\nThroughout this exercise we will use the following libraries:\n\nlibrary(tidyverse)\nlibrary(tidymodels)\n\n#variable importance plots\n\nlibrary(\"vip\")\n\n#Stitching together plots and adding markdown text\n\nlibrary(\"patchwork\")\nlibrary(\"ggtext\")\n\nFor this sessions example, we will also use the white wine data set, but extend it by adding the red wine data set. The red wine data set can be downloaded directly from the UC Irvine Machine Learning Repository or by clicking the button below.\n\nDownload Red Wine Data\n\nA detailed description of each parameter see Cortez et al.\nNote, that importing the red wine data set with the read.csv function requires the argument sep = \";\" which indicates that\nthe columns in the csv are separated by a semicolon.\nAfter importing the data, we add a new column names wine_color that indicates the color of the wine. The wine color will be the target variable, meaning that we try to determine the color of a wine given all the other attributes.\nTo combine both data sets, we can use the rbind() function which binds together the rows of a data set. Before binding together the rows of the data set, we need to make sure that the names of the columns coincide. Otherwise, the columns can’t be matched.\n\ndata_wine_red&lt;-read.csv(\"data/winequality-red.csv\", sep = \";\")\ndata_wine_white&lt;- read.csv(\"data/winequality-white.csv\")\n\ndata_wine_red&lt;- data_wine_red %&gt;% mutate(wine_color = \"red\")\ndata_wine_white&lt;- data_wine_white %&gt;% mutate(wine_color = \"white\")\n\ndata_wine &lt;- rbind(data_wine_red,data_wine_white)\n\nThe newly created data set contains approximately \\(5000\\) wine samples with around \\(25\\%\\) being red wine and the remaining \\(75\\%\\) being white wine.\n\ndata_wine %&gt;% group_by(wine_color) %&gt;%\n  summarise(n = n()) %&gt;%\n  mutate(ratio = n/sum(n))\n\n# A tibble: 2 × 3\n  wine_color     n ratio\n  &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt;\n1 red         1599 0.246\n2 white       4898 0.754\n\n\nSince our data set is imbalanced we should apply stratification in our data split. Stratification ensures that the same ration of red and white wine samples is in the training and testing data. After splitting our data, we can create a 5-fold CV object on the training data.\n\nset.seed(123)\nsplit_wine &lt;- initial_split(data_wine, strata = wine_color)\n\ndata_wine_train &lt;- training(split_wine)\ndata_wine_test &lt;- testing(split_wine)\n\nfolds_wine &lt;- vfold_cv(data_wine_train,5)\n\nThen, we can set up a receipe containing a simple formula and step to convert the target feature wine_color to type factor.\n\nrec_wine &lt;- recipe(\n  wine_color ~.,\n  data = data_wine_train\n  ) %&gt;%\n  step_string2factor(wine_color)\n\nA random forest model can be specified using the rand_forest() function. Additional arguments include, but are not limited to:\n\nmode: indicates whether a classifier or a regression model is specified. (required)\ntrees: indicates the number of trees fitted in the forest. (default = 500)\nmin_n: indicates the minimum number of data points in a node that is required for the node to be split further. (default = 20)\nmtry: indicates the number of variables to possibly split at in each node. (default = sqrt(ncol(data)-1)))\n\nNote, that the mtry parameter depends on the number of independent variables. If mtry = ncol(data)-1, meaning that we select every single independent variable for a potential split, we are creating a bag, rather than a random forest.\nBy setting every hyper parameter to tune(), we specify that the respective hyper parameters are to be tuned.\n\nrf_mod_tune_spec &lt;- rand_forest(\n  mode = \"classification\",\n  trees = tune(),\n  min_n = tune(),\n  mtry = tune()\n) %&gt;%\n  set_engine(\"ranger\", importance = \"permutation\")\n\nAs with any other model, we can create a workflow, add the recipe and model specification, and create a metrics set. The metric set below contains the following metrics:\n\nroc_auc: measures the area under the receiver operator characteristic (values \\(\\in [0,1]\\), with \\(1\\) being the best possible value).\npr_auc: measures the area under the precision-recall curve (values \\(\\in [0,1]\\), with \\(1\\) being the best possible value).\nprecision: measures the positive predictive value (values \\(\\in [0,1]\\), with \\(1\\) being the best possible value).\nrecall: measures the true positive rate (values \\(\\in [0,1]\\), with \\(1\\) being the best possible value).\n\n\nwf_wine &lt;- workflow() %&gt;%\n  add_recipe(rec_wine) %&gt;%\n  add_model(rf_mod_tune_spec)\n\nmulti_metrics &lt;- metric_set(roc_auc,pr_auc,precision,recall)\n\nThe random forest model can be tuned on the 5-fold CV object in the same fashion as every other model. By specifying grid=10, we circumvent specifying the range for the mtry() parameter.\n\n\n\n\n\n\nWarning\n\n\n\nTuning a random forest can take a while. Instead of using 5-fold CV, a simple training/validation/test split can decrease training time.\n\n\n\nrf_tune_res &lt;- wf_wine %&gt;%\n  tune_grid(\n    resamples = folds_wine,\n    metrics = multi_metrics,\n    grid = 10\n  )\n\ni Creating pre-processing data to finalize unknown parameter: mtry\n\n\nWarning: package 'ranger' was built under R version 4.4.1\n\n\nAfter tuning the model, we can select the best set of hyper parameters with respect to different metrics. If we aim for a model that emphasizes correctly classifying the minority class, the metric pr_auc metric can be more useful (why?). We, therefore, select the best parameters according to the metric pr_auc and train a final model using these parameters.\n\nbest_parm_rf_wine &lt;- rf_tune_res %&gt;%\n  select_best(metric = \"pr_auc\")\n\nlast_rf_fit &lt;- wf_wine %&gt;%\n  finalize_workflow(best_parm_rf_wine) %&gt;%\n  last_fit(split_wine,\n           metrics= multi_metrics)\n\nTo evaluate our model, we can either collect the specified metrics using the collect_metrics() function, or generate PR- and ROC-curves.\nThe latter can be achieved with the following Code snippet. We first collect the predictions of the test data using the collect_predictions() function. Then, we generate a ROC- and PR-Curve using the functions roc_curve() and pr_curve(). The roc_curve() function returns a data frame containing three columns:\n\n.threshold: containing the threshold probability for which a sample is assigned to the positive class (in that case red).\nspecificity: containing the specificity of the model for the given thresholds.\nsensitivity: containing the sensitivity of the model for the given thresholds.\n\nThe pr_curve() function returns a similar data frame containing the recall and precision instead of specificity and sensitivity.\n\nrf_auc&lt;- last_rf_fit %&gt;%\n  collect_predictions() %&gt;%\n  roc_curve(wine_color,.pred_red) %&gt;% \n  mutate(model = \"Random Forest\")\n\nrf_pr&lt;- last_rf_fit %&gt;%\n  collect_predictions() %&gt;%\n  pr_curve(wine_color,.pred_red) %&gt;% \n  mutate(model = \"Random Forest\")\n\nWe can generate the curve plots using the autoplot() function or ggplot. An example for both can be found below.\n\nrf_auc %&gt;% autoplot()\n\n\n\n\n\n\n\n\n\nrf_auc %&gt;%\n  ggplot(aes(x = 1 - specificity, y = sensitivity, col = model)) + \n  geom_path(lwd = 1.5) +\n  geom_abline(lty = 3) + \n  coord_equal() + \n  scale_color_manual(values = \"#FFC500\")+\n  labs(\n    title = \"ROC Curve for a random forest \\n that predicts the color of wine\"\n  )+\n  theme_minimal(base_size = 14)+\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\nTo generate a feature importance plot with respect to the measure \"permutation\" feature importance, we first have to extract the fit engine from final model fit and then apply the vip() function of the vip library. The vip function creates a (ggplot) plot, showing the importance scores for the predictors in a model. The geom argument specifies what kind of plot is generated. Setting geom = \"col\" therefore creates a column plot. Other options include \"boxplot\", \"point\", and \"violin\".\n\nlibrary(vip)\n\nlast_rf_fit %&gt;%\n  extract_fit_engine()%&gt;%\n  vip(geom = \"col\",\n           aesthetics = list(fill = \"midnightblue\",\n                             alpha = 0.8)\n           )+\n  theme_minimal(base_size = 14)\n\n\n\n\n\n\n\n\nConsidering the figure above, the variable total.sulfur.dioxide has the highest score which indicates that this variable helps determining the color of the wines most.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Random Forests</span>"
    ]
  },
  {
    "objectID": "05_bagging_rf.html#exercises",
    "href": "05_bagging_rf.html#exercises",
    "title": "5  Random Forests",
    "section": "5.3 Exercises",
    "text": "5.3 Exercises\n\n5.3.1 Theoretical Exercises\nIn this exercise we will discuss some aspects of bootstrap sampling, bagging and random forest.\n\nExercise 5.1 Assume, we have a data set with \\(n\\) sample and a bootstrap sample of size \\(n\\). Furthermore, assume that the probability of an observation not being in the bootstrap sample is \\(\\left(1-\\frac{1}{n}\\right)^n\\). Show that the probability for any sample \\(j\\) to be in the data set is approximately \\(0.6321206\\).\n\n\nExercise 5.2 In terms of bagging, explain the following sentence from the lecture:\n\nHaving similar trees leads to correlated estimates.\n\n\n\nExercise 5.3 Random forests can solve the problem mentioned in Exercise 5.2 of having trees that are too similar. Describe how this is achieved!\n\n\n\n5.3.2 Programming Exercises\nIn this exercise we want to utilize our newly gained knowledge about Bagging and compare a random forest model to a single classification tree and penalized logistic regression.\nThe dataset we will consider in this exercise will be the Credit Card Customers data set that can either be downloaded using the provided link or the button below.\n\nDownload BankChurners\n\nRecall that the data set consists of 10,127 entries that represent individual customers of a bank including but not limited to their age, salary, credit card limit, and credit card category.\nThe main idea for such classification tasks is the following:\n\nStart out by building a simple base model, which allows for an easy interpretation of parameters. A penalized logistic regression will be this base model in our case.\nMove to a slightly more complex model where the interpretation of model parameters is less straight forward, but the model performance increases. The model we will consider for this scenario is a decision tree.\nAs a last step, a highly complex model is trained where the focus is no longer on explainability rather than getting the best possible out of sample performance. An example of such a model is a random forest, which will also be our model of choice for this step.\n\nConsider the following glimpse into the dataset:\n\n\nRows: 10,127\nColumns: 21\n$ CLIENTNUM                &lt;int&gt; 768805383, 818770008, 713982108, 769911858, 7…\n$ Attrition_Flag           &lt;chr&gt; \"Existing Customer\", \"Existing Customer\", \"Ex…\n$ Customer_Age             &lt;int&gt; 45, 49, 51, 40, 40, 44, 51, 32, 37, 48, 42, 6…\n$ Gender                   &lt;chr&gt; \"M\", \"F\", \"M\", \"F\", \"M\", \"M\", \"M\", \"M\", \"M\", …\n$ Dependent_count          &lt;int&gt; 3, 5, 3, 4, 3, 2, 4, 0, 3, 2, 5, 1, 1, 3, 2, …\n$ Education_Level          &lt;chr&gt; \"High School\", \"Graduate\", \"Graduate\", \"High …\n$ Marital_Status           &lt;chr&gt; \"Married\", \"Single\", \"Married\", \"Unknown\", \"M…\n$ Income_Category          &lt;chr&gt; \"$60K - $80K\", \"Less than $40K\", \"$80K - $120…\n$ Card_Category            &lt;chr&gt; \"Blue\", \"Blue\", \"Blue\", \"Blue\", \"Blue\", \"Blue…\n$ Months_on_book           &lt;int&gt; 39, 44, 36, 34, 21, 36, 46, 27, 36, 36, 31, 5…\n$ Total_Relationship_Count &lt;int&gt; 5, 6, 4, 3, 5, 3, 6, 2, 5, 6, 5, 6, 3, 5, 5, …\n$ Months_Inactive_12_mon   &lt;int&gt; 1, 1, 1, 4, 1, 1, 1, 2, 2, 3, 3, 2, 6, 1, 2, …\n$ Contacts_Count_12_mon    &lt;int&gt; 3, 2, 0, 1, 0, 2, 3, 2, 0, 3, 2, 3, 0, 3, 2, …\n$ Credit_Limit             &lt;dbl&gt; 12691.0, 8256.0, 3418.0, 3313.0, 4716.0, 4010…\n$ Total_Revolving_Bal      &lt;int&gt; 777, 864, 0, 2517, 0, 1247, 2264, 1396, 2517,…\n$ Avg_Open_To_Buy          &lt;dbl&gt; 11914.0, 7392.0, 3418.0, 796.0, 4716.0, 2763.…\n$ Total_Amt_Chng_Q4_Q1     &lt;dbl&gt; 1.335, 1.541, 2.594, 1.405, 2.175, 1.376, 1.9…\n$ Total_Trans_Amt          &lt;int&gt; 1144, 1291, 1887, 1171, 816, 1088, 1330, 1538…\n$ Total_Trans_Ct           &lt;int&gt; 42, 33, 20, 20, 28, 24, 31, 36, 24, 32, 42, 2…\n$ Total_Ct_Chng_Q4_Q1      &lt;dbl&gt; 1.625, 3.714, 2.333, 2.333, 2.500, 0.846, 0.7…\n$ Avg_Utilization_Ratio    &lt;dbl&gt; 0.061, 0.105, 0.000, 0.760, 0.000, 0.311, 0.0…\n\n\nSince some of the features are kind of ambiguous, let us briefly talk about what they mean.\n\n\n\n\n\n\n\nFeature\nDescription\n\n\n\n\nCLIENTNUM\nClient number. Unique identifier for the customer holding the account\n\n\nAttrition_Flag\nInternal event (customer activity) variable - if the account is closed then 1 else 0\n\n\nMonths_on_book\nPeriod of relationship with bank\n\n\nMonths_Inactive_12_mon\nNo. of months inactive in the last 12 months\n\n\nCredit_Limit\nCredit Limit on the Credit Card\n\n\nTotal_Revolving_Bal\nPortion of credit card spending that goes unpaid at the end of a billing cycle\n\n\nAvg_Open_To_Buy\nOpen to Buy Credit Line (Average of last 12 months)\n\n\nTotal_Amt_Chng_Q4_Q1\nChange in Transaction Amount (Q4 over Q1)\n\n\nTotal_Trans_Amt\nTotal Transaction Amount (Last 12 months)\n\n\nTotal_Trans_Ct\nTotal Transaction Count (Last 12 months)\n\n\nTotal_Ct_Chng_Q4_Q1\nChange in Transaction Count (Q4 over Q1)\n\n\nAvg_Utilization_Ratio\nAverage Card Utilization Ratio (Divide the total balance by the total credit limit)\n\n\n\n\nExercise 5.4 In the first exercise session, we already performed some exploratory data analysis, focusing on the demographics of the customers. Since we are mainly interested in predicting the attrition flag, find out the no-information rate (NIR) defined by\n\\[\\begin{equation}\n  \\max\\left(\\frac{\\mathrm{P}}{\\mathrm{N+P}},\\frac{\\mathrm{N}}{\\mathrm{N+P}}\\right)\n\\end{equation}\\]\n\n\nExercise 5.5 Create a training and test split using set.seed(121) and a 5-fold CV object based on the training data. Use stratification for the target variable Attrition_Flag to ensure that the ratio of positive and negative sample remains the same in the training and testing data.\n\n\nExercise 5.6 Create a recipe by following the steps described below.\n\nAs a formula, fit the variable Attrition_Flag on every other feature and set the data parameter to data_train.\nUpdate the role of the variable CLIENTNUM by setting it to \"ID\".\nConvert all \"Unknown\" and \"unknown\" values contained in character or factor columns into NA values using the code snippet\n\nacross(where(~is.character(.)|is.factor(.)),~if_else(.%in% c(\"Unknown\",\"unknown\"),NA,.))\n\nConvert the features Income_Category and Education_Level into ordered factors.\nConvert the features Marital_Status, Card_Category, Gender, CLIENTNUM, and the outcome variable Attrition_Flag into factors.\nFor the factor Attrition_Flag, change the labels to \"Inactive\" and \"Active\".\nCreate ordinal scores for all ordered predictors.\nImpute all NA values using kNN imputation.\nCreate dummy variables for all factor predictors.\nApply a zero variance filter on all predictors.\nFamiliarize yourself with the step_corr function, add it to the recipe, and apply it to all predictors.\n\n\n\nExercise 5.7 Create a workflow object and add the newly created recipe rec_ci. Afterwards, create a metric_set that contains the metrics roc_auc,pr_auc,accuracy,precision, and recall.\n\n\nExercise 5.8 (Tuning a lasso model)  \n\nUtilize the logistic_reg function to create a lasso model.\nCreate a regular grid for the logistic model penalty with \\(30\\) levels.\nTune the linear model using the 5-fold CV object created in Exercise 5.5, the grid specified in 2., and the metric set specified in Exercise 5.7.\n\n\n\nExercise 5.9  \n\nGiven the results of the previous exercise, select the best model according to the “one-standard” rule based on the \"pr_auc\" metric.\nTrain a final model on the whole training data.\nCreate two data frames containing the points of the models’ PR- and ROC-curve and visualize them.\n\n\n\nExercise 5.10 (Bonus Exercise) The following exercise is not mandatory but still helps for gaining a deeper understanding of the penalization behavior. Since we have used a lasso logistic regression, some of the parameters might have been driven to 0. Find if there were any!\n\n\nExercise 5.11 Repeat Exercise 5.8 - Exercise 5.9 by tuning a classification tree. Tune the parameters min_n, tree_depth, and cost_complexity using 5-fold CV and a regular grid with four levels. Instead of using the one standard error rule, use the select_best function instead.\n\n\nExercise 5.12 Use the vip::vip function to find the most important features of the final classification tree.\n\n\nExercise 5.13 Repeat Exercise 5.11 and Exercise 5.12 for a random forest model with \\(1000\\) trees. Tune the parameters mtry and min_n with a grid of size \\(10\\) using 5-fold CV.\n\n\nExercise 5.14 Given the following plots, answer the following questions:\n\nWhat can be said about the discriminatory power of the classes?\nWhich curve should be considered for assessing the accurracy of the models?\nWhich model performs the best?\n\n\n\n\n\n\n\n\nExercise 5.15 (Bonus exercise) Use the previously saved data frames containing the ROC- and PR-curve data for each model to recreate the plot in exercise Exercise 5.14",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Random Forests</span>"
    ]
  },
  {
    "objectID": "05_bagging_rf.html#solutions",
    "href": "05_bagging_rf.html#solutions",
    "title": "5  Random Forests",
    "section": "5.4 Solutions",
    "text": "5.4 Solutions\n\nSolution 5.1 (Exercise 5.1). For \\(n\\) sufficiently big, the estimate \\(\\left(1-\\frac{1}{n})^n\\right) \\approx \\exp(-1)\\) holds. Since the probability of any sample not being in the data set is therefore approximately \\(\\exp(-1)\\), we can simply calculate the complementary probability. The complementary probability is given by \\(1-\\exp(-1)\\approx 0.63212\\).\n\n\nSolution 5.2 (Exercise 5.2). Bagging trees leads to fitting many trees with similar structure as the same features tend to be selected in the same step in different trees. Given that the estimates are depending on the splits of a tree, the estimates can be highly correlated if the tree structures are similar.\n\n\nSolution 5.3 (Exercise 5.3). When bagging trees, the number of features for building a tree stays the same. A random forest on the other hand only selects a subset of all the features. This ensures that there is enough variability in the different trees and thus directly tackles the problem of the trees being too similar.\n\n\nSolution 5.4 (Exercise 5.4). \n\nNIR&lt;- credit_info %&gt;%\n  group_by(Attrition_Flag)%&gt;%\n  summarise(n=n()) %&gt;%\n  mutate(NIR = n/sum(n)) %&gt;%\n  pluck(3) %&gt;%\n  max()\n\nglue::glue(\"The NIR of the underlying dataset is {round(NIR,3)},\n           meaning that a classification model should have\n           an accuracy of at least {round(NIR,3)}.\")\n\nThe NIR of the underlying dataset is 0.839,\nmeaning that a classification model should have\nan accuracy of at least 0.839.\n\n\n\n\nSolution 5.5 (Exercise 5.5). Create a training and test split using set.seed(121) and a 5-fold CV object based on the training data.\n\nset.seed(121)\nsplit &lt;- initial_split(credit_info, strata = Attrition_Flag)\ndata_train_ci &lt;- training(split)\ndata_test_ci &lt;- testing(split)\nfolds_ci &lt;- vfold_cv(data_train_ci, v = 5)\n\n\n\nSolution 5.6 (Exercise 5.6). \n\nlevels_income &lt;- c(\"Less than $40K\",\"$40K - $60K\",\n                   \"$60K - $80K\",\"$80K - $120K\",\"$120K +\")\n\nlevels_education &lt;- c(\"Uneducated\", \"High School\",\"College\",\n                      \"Graduate\",  \"Post-Graduate\", \"Doctorate\")\n\nrec_ci &lt;- recipe(Attrition_Flag ~., data = data_train_ci) %&gt;%\n  update_role(CLIENTNUM, new_role = \"ID\") %&gt;%\n  step_mutate_at(all_nominal_predictors(),\n               fn = ~if_else(.%in% c(\"Unknown\",\"unknown\"),NA,.)\n               ) %&gt;%\n  step_string2factor(Income_Category,\n                     levels = levels_income,\n                     ordered = TRUE) %&gt;%\n  step_string2factor(Education_Level,\n                     levels = levels_education,\n                     ordered = TRUE) %&gt;%\n  step_string2factor(Attrition_Flag) %&gt;%\n  step_ordinalscore(all_ordered_predictors()) %&gt;%\n  step_unknown(all_factor_predictors()) %&gt;%\n  step_impute_knn(all_predictors()) %&gt;%\n  step_dummy(all_nominal_predictors()) %&gt;%\n  step_zv(all_predictors()) %&gt;%\n  step_corr(all_predictors())\n\n\n\nSolution 5.7 (Exercise 5.7). \n\nci_wf &lt;- workflow() %&gt;%\n  add_recipe(rec_ci) \n\nmulti_metrics &lt;- metric_set(roc_auc,pr_auc,accuracy,recall)\n\n\n\nSolution 5.8 (Exercise 5.8). \n\nlog_mod_tune_spec &lt;-logistic_reg(penalty = tune(), mixture = 1) %&gt;%\n  set_engine(\"glmnet\")\n\nci_wf &lt;- ci_wf %&gt;% add_model(log_mod_tune_spec)\n\nlr_grid &lt;- ci_wf %&gt;%\n  extract_parameter_set_dials %&gt;%\n  grid_regular(levels = 30)\n\nlr_tune_res &lt;- ci_wf %&gt;%\n  tune_grid(\n    grid = lr_grid,\n    metrics = multi_metrics,\n    resamples = folds_ci\n  )\n\nWarning: package 'glmnet' was built under R version 4.4.1\n\n\n\n\nSolution 5.9 (Exercise 5.9). \n\nlr_res_best &lt;- lr_tune_res %&gt;%\n  select_by_one_std_err(metric = \"pr_auc\", desc(penalty))\n\nlast_lr_fit &lt;- ci_wf %&gt;%\n  finalize_workflow(lr_res_best) %&gt;%\n  last_fit(split,\n           metrics = multi_metrics)\n\nlr_auc&lt;- last_lr_fit %&gt;%\n  collect_predictions() %&gt;%\n  roc_curve(Attrition_Flag,`.pred_Attrited Customer`) %&gt;% \n  mutate(model = \"Logistic Regression\")\n\nlr_pr&lt;- last_lr_fit %&gt;%\n  collect_predictions() %&gt;%\n  pr_curve(Attrition_Flag,`.pred_Attrited Customer`) %&gt;%\n  mutate(model = \"Logistic Regression\")\n\n\np1 &lt;- lr_auc %&gt;%\n  ggplot(aes(x = 1 - specificity, y = sensitivity, col = model)) + \n  geom_path(lwd = 1.5, alpha = 0.8) +\n  geom_abline(lty = 3) + \n  coord_equal() + \n  scale_color_viridis_d(option = \"plasma\", end = .6)+\n  ylim(c(0,1))+\n  theme(legend.position = \"none\")\n\np2 &lt;- lr_pr %&gt;%\n  ggplot(aes(x = recall, y = precision, col = model)) + \n  geom_path(lwd = 1.5, alpha = 0.8) +\n  coord_equal() + \n  scale_color_viridis_d(option = \"plasma\", end = .6)+\n  ylim(c(0,1))+\n  theme(legend.position = \"none\")\n\np&lt;-p1 | p2\n\np + plot_annotation(\n  title = \"ROC curve and Precision-Recall curve for a penalized logistic regression\"\n)\n\n\n\n\n\n\n\n\n\n\nExercise 5.16 (Exercise 5.16)  \n\nlast_lr_fit %&gt;%\n  extract_fit_parsnip() %&gt;%\n  tidy() %&gt;%\n  filter(estimate == 0) %&gt;%\n  select(term)\n\n# A tibble: 10 × 1\n   term                          \n   &lt;chr&gt;                         \n 1 Avg_Utilization_Ratio         \n 2 Education_Level_Graduate      \n 3 Education_Level_High.School   \n 4 Education_Level_Uneducated    \n 5 Education_Level_unknown       \n 6 Marital_Status_unknown        \n 7 Income_Category_X.40K....60K  \n 8 Income_Category_X.80K....120K \n 9 Income_Category_Less.than..40K\n10 Income_Category_unknown       \n\nlast_lr_fit %&gt;%\n  extract_fit_parsnip() %&gt;%\n  tidy() %&gt;%\n  filter(estimate &gt; 0) %&gt;%\n  arrange(desc(estimate)) %&gt;%\n  select(term)\n\n# A tibble: 11 × 1\n   term                        \n   &lt;chr&gt;                       \n 1 Total_Ct_Chng_Q4_Q1         \n 2 Gender_M                    \n 3 Total_Relationship_Count    \n 4 Marital_Status_Married      \n 5 Total_Amt_Chng_Q4_Q1        \n 6 Total_Trans_Ct              \n 7 Income_Category_X.60K....80K\n 8 Months_on_book              \n 9 Customer_Age                \n10 Total_Revolving_Bal         \n11 Credit_Limit                \n\n\n\n\nSolution 5.10 (Exercise 5.11). \n\nct_model_spec &lt;- decision_tree(\n  min_n = tune(),\n  tree_depth = tune(),\n  cost_complexity = tune()\n) %&gt;%\n  set_mode(\"classification\")\n\nci_wf &lt;- ci_wf %&gt;% update_model(ct_model_spec)\nct_grid &lt;- ci_wf %&gt;%\n  extract_parameter_set_dials() %&gt;%\n  grid_regular(levels = 4)\n\nct_tune_res &lt;- ci_wf %&gt;%\n tune_grid(\n   grid = ct_grid,\n   metrics = multi_metrics,\n   resamples = folds_ci\n)\n\nct_res_best &lt;- ct_tune_res %&gt;% \n  select_best(metric = \"pr_auc\")\n\nlast_ct_fit &lt;- ci_wf %&gt;%\n  finalize_workflow(ct_res_best) %&gt;%\n  last_fit(split,\n           metrics = multi_metrics)\n\n\nct_auc&lt;- last_ct_fit %&gt;%\n  collect_predictions() %&gt;%\n  roc_curve(Attrition_Flag,`.pred_Attrited Customer`) %&gt;%\n  mutate(model = \"Classification Tree\")\n\nct_pr&lt;- last_ct_fit %&gt;%\n  collect_predictions() %&gt;%\n  pr_curve(Attrition_Flag,`.pred_Attrited Customer`) %&gt;%\n  mutate(model = \"Classification Tree\")\n\np1 &lt;- ct_auc %&gt;%\n  ggplot(aes(x = 1 - specificity, y = sensitivity, col = model)) + \n  geom_path(lwd = 1.5, alpha = 0.8) +\n  geom_abline(lty = 3) + \n  coord_equal() + \n  scale_color_viridis_d(option = \"plasma\", end = .6)+\n  ylim(c(0,1))+\n  theme(legend.position = \"none\")\n\np2 &lt;- ct_pr %&gt;%\n  ggplot(aes(x = recall, y = precision, col = model)) + \n  geom_path(lwd = 1.5, alpha = 0.8) +\n  coord_equal() + \n  scale_color_viridis_d(option = \"plasma\", end = .6)+\n  ylim(c(0,1))+\n  theme(legend.position = \"none\")\n\np&lt;-p1 | p2\n\np + plot_annotation(\n  title = \"ROC curve and Precision-Recall curve for a classification tree\"\n)\n\n\n\n\n\n\n\n\n\n\nSolution 5.11 (Exercise 5.12). \n\nlast_ct_fit %&gt;%\n  extract_fit_engine()%&gt;%\n  vip(geom = \"col\", aesthetics = list(fill = \"midnightblue\", alpha = 0.8)) +\n  scale_y_continuous(expand = c(0, 0))\n\n\n\n\n\n\n\n\n\n\nSolution 5.12 (Exercise 5.13). \n\ncores &lt;- parallel::detectCores()\n\nrf_model_spec &lt;- rand_forest(\n  mode = \"classification\",\n  mtry = tune(),\n  min_n = tune(),\n  trees = 1000\n) %&gt;%\n  set_engine(\"ranger\",\n             num.threads = cores,\n             importance = \"impurity\")\n\nci_wf &lt;- ci_wf %&gt;% update_model(rf_model_spec)\n\nrf_res &lt;- ci_wf %&gt;% \n  tune_grid(grid = 10,\n            metrics = multi_metrics,\n            resamples = folds_ci,\n            control = control_grid(save_pred = TRUE)\n  )\n\ni Creating pre-processing data to finalize unknown parameter: mtry\n\nrf_res_best &lt;- rf_res %&gt;% select_best(metric = \"roc_auc\")\n\nrf_auc &lt;- \n  rf_res %&gt;% \n  collect_predictions(parameters = rf_res_best) %&gt;% \n  roc_curve(Attrition_Flag, `.pred_Attrited Customer`) %&gt;% \n  mutate(model = \"Random Forest\")\n\nrf_pr &lt;- \n  rf_res %&gt;% \n  collect_predictions(parameters = rf_res_best) %&gt;% \n  pr_curve(Attrition_Flag, `.pred_Attrited Customer`) %&gt;% \n  mutate(model = \"Random Forest\")\n\np1 &lt;- rf_auc %&gt;%\n  ggplot(aes(x = 1 - specificity, y = sensitivity, col = model)) + \n  geom_path(lwd = 1.5, alpha = 0.8) +\n  geom_abline(lty = 3) + \n  coord_equal() + \n  scale_color_viridis_d(option = \"plasma\", end = .6)+\n  ylim(c(0,1))+\n  theme(legend.position = \"none\")\n\np2 &lt;- rf_pr %&gt;%\n  ggplot(aes(x = recall, y = precision, col = model)) + \n  geom_path(lwd = 1.5, alpha = 0.8) +\n  coord_equal() + \n  scale_color_viridis_d(option = \"plasma\", end = .6)+\n  ylim(c(0,1))+\n  theme(legend.position = \"none\")\n\np&lt;-p1 | p2\n\np + plot_annotation(\n  title = \"ROC Curve and Precision-Recall curve for a random forest\"\n)\n\n\n\n\n\n\n\n\nFeature importance plot:\n\nlast_rf_fit &lt;- ci_wf %&gt;%\n  finalize_workflow(rf_res_best) %&gt;%\n  last_fit(split)\n\nlast_rf_fit %&gt;%\n  extract_fit_parsnip()%&gt;%\n  vip(geom = \"col\", aesthetics = list(fill = \"midnightblue\", alpha = 0.8)) +\n  scale_y_continuous(expand = c(0, 0))\n\n\n\n\n\n\n\n\n\n\nSolution 5.13 (Exercise 5.15). \n\n\nSolution 5.14 (Exercise 5.15). \n\ncols &lt;- c(\"#80003A\",\"#506432\",\"#FFC500\")\nnames(cols) &lt;- c(\"cl\", \"lr\", \"rf\")\nplot_title &lt;- glue::glue(\"ROC- and PR-curve for &lt;span style='color:{cols['lr']};'&gt;penalized logistic regression&lt;/span&gt;,&lt;br&gt;\n                         &lt;span style='color:{cols['cl']};'&gt;classification tree&lt;/span&gt;,\n                         and &lt;span style='color:{cols['rf']};'&gt;random forest&lt;/span&gt;\")\np1 &lt;- bind_rows(ct_auc, lr_auc, rf_auc) %&gt;% \n  ggplot(aes(x = 1 - specificity, y = sensitivity, col = model)) + \n  geom_path(lwd = 1.5) +\n  geom_abline(lty = 3) + \n  coord_equal() + \n  scale_color_manual(values = unname(cols))+\n  theme_minimal(base_size = 14)+\n  theme(legend.position = \"none\")\n  \n\np2 &lt;- bind_rows(ct_pr, lr_pr, rf_pr) %&gt;% \n  ggplot(aes(x = recall, y = precision, col = model)) + \n  geom_path(lwd = 1.5, alpha = 0.8) +\n  coord_equal() + \n  scale_color_manual(values = unname(cols))+\n  theme_minimal(base_size = 14)+\n  theme(legend.position = \"none\")\n  \n\n(p1|p2) +\n  plot_annotation(\n  title = plot_title,\n  theme = theme(plot.title = element_markdown()))",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Random Forests</span>"
    ]
  },
  {
    "objectID": "05_bagging_rf.html#session-info",
    "href": "05_bagging_rf.html#session-info",
    "title": "5  Random Forests",
    "section": "5.5 Session Info",
    "text": "5.5 Session Info\n\nsessionInfo()\n\nR version 4.4.0 (2024-04-24 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] rpart_4.1.23       glmnet_4.1-8       Matrix_1.7-0       ranger_0.16.0     \n [5] ggtext_0.1.2       patchwork_1.2.0    vip_0.4.1          yardstick_1.3.1   \n [9] workflowsets_1.1.0 workflows_1.1.4    tune_1.2.1         rsample_1.2.1     \n[13] recipes_1.0.10     parsnip_1.2.1      modeldata_1.3.0    infer_1.0.7       \n[17] dials_1.2.1        scales_1.3.0       broom_1.0.5        tidymodels_1.2.0  \n[21] lubridate_1.9.3    forcats_1.0.0      stringr_1.5.1      dplyr_1.1.4       \n[25] purrr_1.0.2        readr_2.1.5        tidyr_1.3.1        tibble_3.2.1      \n[29] ggplot2_3.5.1      tidyverse_2.0.0   \n\nloaded via a namespace (and not attached):\n [1] rlang_1.1.3         magrittr_2.0.3      furrr_0.3.1        \n [4] compiler_4.4.0      vctrs_0.6.5         lhs_1.1.6          \n [7] pkgconfig_2.0.3     shape_1.4.6.1       crayon_1.5.2       \n[10] fastmap_1.1.1       backports_1.4.1     ellipsis_0.3.2     \n[13] labeling_0.4.3      utf8_1.2.4          rmarkdown_2.26     \n[16] prodlim_2023.08.28  markdown_1.12       tzdb_0.4.0         \n[19] xfun_0.43           jsonlite_1.8.8      parallel_4.4.0     \n[22] R6_2.5.1            stringi_1.8.4       parallelly_1.37.1  \n[25] Rcpp_1.0.12         iterators_1.0.14    knitr_1.46         \n[28] future.apply_1.11.2 splines_4.4.0       nnet_7.3-19        \n[31] timechange_0.3.0    tidyselect_1.2.1    rstudioapi_0.16.0  \n[34] yaml_2.3.8          timeDate_4032.109   codetools_0.2-20   \n[37] listenv_0.9.1       lattice_0.22-6      withr_3.0.0        \n[40] evaluate_0.23       future_1.33.2       survival_3.5-8     \n[43] xml2_1.3.6          pillar_1.9.0        foreach_1.5.2      \n[46] generics_0.1.3      hms_1.1.3           commonmark_1.9.1   \n[49] munsell_0.5.1       globals_0.16.3      class_7.3-22       \n[52] glue_1.7.0          tools_4.4.0         data.table_1.15.4  \n[55] gower_1.0.1         grid_4.4.0          ipred_0.9-14       \n[58] colorspace_2.1-0    cli_3.6.2           DiceDesign_1.10    \n[61] fansi_1.0.6         viridisLite_0.4.2   lava_1.8.0         \n[64] gtable_0.3.5        GPfit_1.0-8         digest_0.6.35      \n[67] htmlwidgets_1.6.4   farver_2.1.1        htmltools_0.5.8.1  \n[70] lifecycle_1.0.4     hardhat_1.3.1       gridtext_0.1.5     \n[73] MASS_7.3-60.2",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Random Forests</span>"
    ]
  }
]